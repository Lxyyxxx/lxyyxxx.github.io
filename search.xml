<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>「学习笔记」RSA中的数论</title>
      <link href="/2022/10/RSA/"/>
      <url>/2022/10/RSA/</url>
      
        <content type="html"><![CDATA[<h1 id="费马小定理"><a class="header-anchor" href="#费马小定理"># </a>费马小定理</h1><p>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 是素数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 是正整数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(a, p)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>≡</mo><mn>1</mn><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">a ^ {p - 1} \equiv 1 \mod p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span></span></span></span>。<br>另一种形式：若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 是素数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 是正整数，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mi>p</mi></msup><mo>≡</mo><mi>a</mi><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">a ^ p \equiv a \mod p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span></span></span></span>。</p><h1 id="欧拉函数"><a class="header-anchor" href="#欧拉函数"># </a>欧拉函数</h1><p>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 是正整数，小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 且与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 互质的正整数的个数称为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的欧拉函数，记为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varphi(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p><ul><li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 是素数，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\varphi(n) = n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</li><li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mi>p</mi><mo>×</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">n = p \times q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 都是素数，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>φ</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>×</mo><mi>φ</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi>q</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varphi(n) = \varphi(p) \times \varphi(q) = (p - 1) \times (q - 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li></ul><h1 id="欧拉定理"><a class="header-anchor" href="#欧拉定理"># </a>欧拉定理</h1><p>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 互素，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></msup><mo>≡</mo><mn>1</mn><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">a ^ {\varphi(n)} \equiv 1 \mod n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">φ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span>。</p><blockquote><p>费马小定理是欧拉定理的特殊情况：当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">n = p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>p</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\varphi(n) = p - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p></blockquote><h1 id="Miller-Rabin-概率检测素数算法"><a class="header-anchor" href="#Miller-Rabin-概率检测素数算法"># </a>Miller-Rabin 概率检测素数算法</h1><p>原理：</p><ol><li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 为大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的素数，则方程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>≡</mo><mn>1</mn><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">x ^ 2 \equiv 1 \mod p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span></span></span></span> 的解只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x = -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</li><li><a href="#%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86">费马小定理</a>。</li></ol><pre><code class="language-cpp">/* * 用法：取不同的 2 &lt;= a &lt; n，检测 n 是否是素数 * 输入：a, n * 输出：若返回 false，则 n 一定不是素数，否则 n 有概率是素数 */bool witness(const int &amp; a, const int &amp;n)  {    b = n - 1, k = -1;    while (b) b &gt;&gt;= 1, k++;  // bk...b0    b = n - 1;  // 用于算 a ^ (n - 1) % n    d = 1;  // 两个用途：d = x ^ 2 % n, d = a ^ (n - 1) % n    for (int i = k; i &gt;= 0; i--) {        x = d;        d = d * d % n;  // d = x ^ 2 % n        if (d == 1 &amp;&amp; x != 1 &amp;&amp; x != n - 1) return false;  // 违反了解只有 1 和 -1        if (b &gt;&gt; i &amp; 1 == 1) d = d * a % n;  // bi = 1    }    if (d != 1) return false;  // 违反了费马小定理    return true;}</code></pre><h1 id="欧几里得算法-辗转相除法"><a class="header-anchor" href="#欧几里得算法-辗转相除法"># </a>欧几里得算法 / 辗转相除法</h1><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a, b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span></span></span></span> 是任意两个正整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>&gt;</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a &gt; b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>，它们的最大公因子 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(a, b) = gcd(b, a \mod b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>。<br>停止条件：</p><ul><li>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a \mod b = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">gcd(a, b) = b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>。</li><li>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>b</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a \mod b = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>b</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(a, b) = a \mod b = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</li></ul><h1 id="扩展欧几里得算法"><a class="header-anchor" href="#扩展欧几里得算法"># </a>扩展欧几里得算法</h1><p>通过辗转相除法可推出：存在整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo separator="true">,</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">s, t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span></span></span></span>，使得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>a</mi><mo>+</mo><mi>t</mi><mi>b</mi><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">sa + tb = gcd(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>，即两个数的最大公因数可以由这两个数线性表示。<br>扩展欧几里得算法先通过<a href="#%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95-%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95">欧几里得算法</a>求出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>，若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(a, b) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，则有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>a</mi><mo>+</mo><mi>t</mi><mi>b</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">sa + tb = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>b</mi><mo>≡</mo><mn>1</mn><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>a</mi></mrow><annotation encoding="application/x-tex">tb \equiv 1 \mod a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>a</mi></mrow><annotation encoding="application/x-tex">\mod a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span></span></span></span> 下有乘法逆元 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>。</p><pre><code class="language-cpp">/* * 用法：求解 ax + by = gcd(a, b) 中的 x 和 y * 输入：a, b (a &gt; b) * 输出：返回是否有乘法逆元。若 y3 = 1，则有 gcd(a, b) = 1，即 b 在 mod a 下有乘法逆元 y；否则 gcd(a, b) = x3，无乘法逆元 */bool extendedEuclid(const int &amp;a, const int &amp;b, int &amp;x, int &amp;y) {    int x3 = a, y3 = b;  // 用于辗转相除求 gcd(a, b)    int x1 = 1, y1 = 0;  // 满足 ax1 + bx = x3 = a, ay1 + by = y3 = b    x = 0, y = 1;    int t1, t2, t3, q;    while (y3 != 0 &amp;&amp; y3 != 1) {  // 辗转相除还未到停止条件        q = x3 / y3;        t1 = x1 - q * y1, t2 = x - q * y, t3 = x3 - q * y3;        x1 = y1, x = y, x3 = y3;        y1 = t1, y = t2, y3 = t3;  // 通过数学归纳法可得到 ay1 + by = y3，当 y3 = 1 时，gcd(a, b) = 1，即 ay1 + by = 1，b 在 mod a 下有乘法逆元 y    }    while (y &lt; 0) y += a;  // 求解出来的 y 可能是负数    return y3 == 1 || x == 1;}</code></pre><h1 id="求乘法逆元"><a class="header-anchor" href="#求乘法逆元"># </a>求乘法逆元</h1><ul><li><a href="#%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86">费马小定理</a>：若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 是素数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 是正整数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(a, p)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">\mod p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span></span></span></span> 下的乘法逆元为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>p</mi><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">a ^ {p - 2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>。</li><li><a href="#%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">扩展欧几里得</a>：若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mtext>  </mtext><mo stretchy="false">(</mo><mi>a</mi><mo>&gt;</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a, b \; (a &gt; b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> 是正整数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(a, b)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>a</mi></mrow><annotation encoding="application/x-tex">\mod a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span></span></span></span> 下的乘法逆元为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mtext>  </mtext><mo stretchy="false">(</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y \; (ax + by = 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li></ul><blockquote><p>在 RSA 中，已知公钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span> 和欧拉函数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varphi(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，需要求满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>⋅</mo><mi>e</mi><mo>≡</mo><mn>1</mn><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d \cdot e \equiv 1 \mod \varphi(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的私钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>。因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>q</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varphi(n) = (p - 1)(q - 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 必为合数，所以不可用费马小定理求解。因为选取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span> 时满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>e</mi><mo separator="true">,</mo><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(e, \varphi(n)) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，所以可用扩展欧几里得求解，且必存在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 一起学习吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 信息安全 </tag>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Visual Studio 帮助学习《计算机组成原理》</title>
      <link href="/2020/09/VSCO/"/>
      <url>/2020/09/VSCO/</url>
      
        <content type="html"><![CDATA[<p>x86采用小端方式存储数据，数据按边界对齐存储</p><h1 id="C"><a class="header-anchor" href="#C"># </a>C++</h1><h2 id="设置C-断点"><a class="header-anchor" href="#设置C-断点"># </a>设置C++断点</h2><p><img src="/2020/09/VSCO/1.jpg" alt="1"></p><h2 id="查看C-变量地址"><a class="header-anchor" href="#查看C-变量地址"># </a>查看C++变量地址</h2><p>点击【开始调试】后<br>打开【调试】【快速监视】输入<code>&amp;变量</code>（即：取地址），点【重新计算】，即可得到变量的地址<br><img src="/2020/09/VSCO/2.jpg" alt="2"></p><h2 id="查看内存"><a class="header-anchor" href="#查看内存"># </a>查看内存</h2><p>点击【开始调试】后<br>打开【调试】【窗口】【内存】，即可调出内存窗口<br>输入变量地址即可查看内存中该变量的存储情况<br><img src="/2020/09/VSCO/3.jpg" alt="3"></p><h2 id="查看C-生成的汇编语言"><a class="header-anchor" href="#查看C-生成的汇编语言"># </a>查看C++生成的汇编语言</h2><p>点击【开始调试】后<br>打开【调试】【窗口】【反汇编】，即可看到C++生成的汇编语言<br><img src="/2020/09/VSCO/4.jpg" alt="4"></p><h2 id="查看寄存器"><a class="header-anchor" href="#查看寄存器"># </a>查看寄存器</h2><p>点击【开始调试】后<br>打开【调试】【窗口】【寄存器】，即可看到各寄存器中的数据<br><img src="/2020/09/VSCO/5.jpg" alt="5"></p><hr><h1 id="ASM"><a class="header-anchor" href="#ASM"># </a>ASM</h1><h2 id="ASM配置"><a class="header-anchor" href="#ASM配置"># </a>ASM配置</h2><ol><li><p>创建一个 Visual C++ 空工程，此时先不要添加汇编源文件</p></li><li><p>在【解决方案浏览器】视图中，在【项目名称】上右击选择【生成依赖项】【生成自定义】，勾选【masm(.targets, .props)】项<br><img src="/2020/09/VSCO/6.jpg" alt="6"></p></li><li><p>在【解决方案浏览器】视图中，在【项目名称】上右击选择【属性】，在左侧【配置属性】导航中，选择【链接器】【系统】， 在【子系统】右侧下拉菜单中选择【控制台(/SUBSYSTEM:CONSOLE)】<br><img src="/2020/09/VSCO/7.jpg" alt="7"></p></li><li><p>添加汇编源代码<code>filename.asm</code>（添加C++文件，然后修改为<code>.asm</code>后缀），（这一步要放在最后，否则可能会报错）</p></li></ol><h2 id="引入依赖库Irvine"><a class="header-anchor" href="#引入依赖库Irvine"># </a>引入依赖库Irvine</h2><ol><li><p>链接器中添加包含路径：在【解决方案资源管理器】中, 项目名称上右击选择【属性】【链接器】【常规】【附加库目录】，<code>C:\Irvine</code><br><img src="/2020/09/VSCO/8.jpg" alt="8"></p></li><li><p>链接器中添加附加依赖项：在【解决方案资源管理器】中, 项目名称上右击选择【属性】【链接器】【输入】【附加依赖项】，主要包含库: <code>user32.lib</code>，<code>Irvine32.lib</code>，<code>kernel32.Lib</code><br><img src="/2020/09/VSCO/9.jpg" alt="9"></p></li></ol><h2 id="运行ASM"><a class="header-anchor" href="#运行ASM"># </a>运行ASM</h2><ol><li><p>设置断点<br><img src="/2020/09/VSCO/10.jpg" alt="10"></p></li><li><p>在运行时可能会出现【系统资源不足】无法运行的提示，只要将McAfee关掉即可</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 搞点什么东东吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「LeetCode」多线程</title>
      <link href="/2020/03/LeetcodeMultithreading/"/>
      <url>/2020/03/LeetcodeMultithreading/</url>
      
        <content type="html"><![CDATA[<p><em>不含经典会员才能做的题</em></p><h1 id="1114-按序打印"><a class="header-anchor" href="#1114-按序打印"># </a>1114 按序打印</h1><p><a href="https://leetcode-cn.com/problems/print-in-order/" target="_blank" rel="noopener">传送门</a></p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">执行用时</th><th style="text-align:center">内存消耗</th><th style="text-align:center">提交时间</th></tr></thead><tbody><tr><td style="text-align:center"><code>packaged_task</code></td><td style="text-align:center">56 ms</td><td style="text-align:center">7.2 MB</td><td style="text-align:center">2022/03/22 22:49</td></tr><tr><td style="text-align:center"><code>future promise</code></td><td style="text-align:center">76 ms</td><td style="text-align:center">7.2 MB</td><td style="text-align:center">2022/03/22 22:31</td></tr><tr><td style="text-align:center"><code>condition_variable</code></td><td style="text-align:center">84 ms</td><td style="text-align:center">6.9 MB</td><td style="text-align:center">2022/03/22 22:14</td></tr><tr><td style="text-align:center"><code>semaphore.h (Linux)</code></td><td style="text-align:center">144 ms</td><td style="text-align:center">8.2 MB</td><td style="text-align:center">2020/03/20 13:57</td></tr><tr><td style="text-align:center"><code>semaphore (C++20)</code></td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center"><code>mutex</code></td><td style="text-align:center">124 ms</td><td style="text-align:center">8.3 MB</td><td style="text-align:center">2020/03/20 23:24</td></tr><tr><td style="text-align:center"><code>lock_guard&lt;mutex&gt;</code></td><td style="text-align:center">160 ms</td><td style="text-align:center">8.2 MB</td><td style="text-align:center">2020/03/20 23:32</td></tr><tr><td style="text-align:center"><code>atomic_flag</code></td><td style="text-align:center">1516 ms</td><td style="text-align:center">7.1 MB</td><td style="text-align:center">2023/03/23 00:05</td></tr><tr><td style="text-align:center"><code>atomic_bool</code></td><td style="text-align:center">1644 ms</td><td style="text-align:center">7 MB</td><td style="text-align:center">2023/03/23 00:41</td></tr></tbody></table><h2 id="任务-C-11"><a class="header-anchor" href="#任务-C-11"># </a>任务 (C++ 11)</h2><h3 id="packaged-task"><a class="header-anchor" href="#packaged-task"># </a>packaged_task</h3><pre><code class="language-cpp">class Foo {    using TASK_TYPE = void();    function&lt;TASK_TYPE&gt; task = [](){};    packaged_task&lt;TASK_TYPE&gt; pt1{task}, pt2{task};public:    Foo() {            }    void first(function&lt;void()&gt; printFirst) {                // printFirst() outputs &quot;first&quot;. Do not change or remove this line.        printFirst();        pt1();    }    void second(function&lt;void()&gt; printSecond) {        future&lt;void&gt; f{pt1.get_future()};        f.get();        // printSecond() outputs &quot;second&quot;. Do not change or remove this line.        printSecond();        pt2();    }    void third(function&lt;void()&gt; printThird) {        future&lt;void&gt; f{pt2.get_future()};        f.get();        // printThird() outputs &quot;third&quot;. Do not change or remove this line.        printThird();    }};</code></pre><h3 id="future-和-promise"><a class="header-anchor" href="#future-和-promise"># </a>future 和 promise</h3><pre><code class="language-cpp">class Foo {    promise&lt;bool&gt; p1, p2;public:    Foo() {            }    void first(function&lt;void()&gt; printFirst) {                // printFirst() outputs &quot;first&quot;. Do not change or remove this line.        printFirst();        p1.set_value(true);    }    void second(function&lt;void()&gt; printSecond) {        future&lt;bool&gt; f{p1.get_future()};        f.wait();        // printSecond() outputs &quot;second&quot;. Do not change or remove this line.        printSecond();        p2.set_value(true);    }    void third(function&lt;void()&gt; printThird) {        future&lt;bool&gt; f{p2.get_future()};        f.wait();        // printThird() outputs &quot;third&quot;. Do not change or remove this line.        printThird();    }};</code></pre><h2 id="条件变量-C-11"><a class="header-anchor" href="#条件变量-C-11"># </a>条件变量 (C++ 11)</h2><pre><code class="language-cpp">class Foo {    mutex m1, m2;    condition_variable cv1, cv2;    int cur;public:    Foo() {        cur = 0;    }    void first(function&lt;void()&gt; printFirst) {                // printFirst() outputs &quot;first&quot;. Do not change or remove this line.        printFirst();        cur = 1;        cv1.notify_one();    }    void second(function&lt;void()&gt; printSecond) {        unique_lock&lt;mutex&gt; lock{m1};        cv1.wait(lock, [this](){return cur == 1;});        // printSecond() outputs &quot;second&quot;. Do not change or remove this line.        printSecond();        lock.unlock();        cur = 2;        cv2.notify_one();    }    void third(function&lt;void()&gt; printThird) {        unique_lock&lt;mutex&gt; lock{m2};        cv2.wait(lock, [this](){return cur == 2;});        // printThird() outputs &quot;third&quot;. Do not change or remove this line.        printThird();        lock.unlock();        cur = 3;    }};</code></pre><h2 id="信号量"><a class="header-anchor" href="#信号量"># </a>信号量</h2><h3 id="semaphore-h-Linux"><a class="header-anchor" href="#semaphore-h-Linux"># </a>semaphore.h (Linux)</h3><pre><code class="language-cpp">#include &lt;semaphore.h&gt;class Foo {private:    sem_t s1,s2;public:    Foo() {        sem_init(&amp;s1,0,0);        sem_init(&amp;s2,0,0);    }    void first(function&lt;void()&gt; printFirst) {         // printFirst() outputs &quot;first&quot;. Do not change or remove this line.        printFirst();        sem_post(&amp;s1);    }    void second(function&lt;void()&gt; printSecond) {        sem_wait(&amp;s1);        // printSecond() outputs &quot;second&quot;. Do not change or remove this line.        printSecond();        sem_post(&amp;s2);    }    void third(function&lt;void()&gt; printThird) {        sem_wait(&amp;s2);        // printThird() outputs &quot;third&quot;. Do not change or remove this line.        printThird();    }};</code></pre><h3 id="semaphore-C-20-LeetCode-不支持"><a class="header-anchor" href="#semaphore-C-20-LeetCode-不支持"># </a>semaphore (C++ 20) LeetCode 不支持</h3><pre><code class="language-cpp">#include &lt;functional&gt;#include &lt;iostream&gt;#include &lt;semaphore&gt;#include &lt;thread&gt;#include &lt;vector&gt;using namespace std;class Foo {    binary_semaphore s1{0}, s2{0};   public:    Foo() {}    void first(function&lt;void()&gt; printFirst) {        // printFirst() outputs &quot;first&quot;. Do not change or remove this line.        printFirst();        s1.release();    }    void second(function&lt;void()&gt; printSecond) {        s1.acquire();        // printSecond() outputs &quot;second&quot;. Do not change or remove this line.        printSecond();        s2.release();    }    void third(function&lt;void()&gt; printThird) {        s2.acquire();        // printThird() outputs &quot;third&quot;. Do not change or remove this line.        printThird();    }};int main() {    vector&lt;int&gt; order{3, 2, 1};    vector&lt;thread&gt; pool;    Foo foo = Foo();    for (int i : order) {        if (i == 1)            pool.emplace_back(&amp;Foo::first, &amp;foo, []() {                cout &lt;&lt; &quot;first&quot;;            });  // 与成员函数绑定需要用                 // &amp;类名::成员函数名，再传递对象，再传递参数        else if (i == 2)            pool.emplace_back(&amp;Foo::second, &amp;foo, []() { cout &lt;&lt; &quot;second&quot;; });        else if (i == 3)            pool.emplace_back(&amp;Foo::third, &amp;foo, []() { cout &lt;&lt; &quot;third&quot;; });    }    for (thread &amp;t : pool) {        t.join();    }}</code></pre><h2 id="互斥信号量-C-11"><a class="header-anchor" href="#互斥信号量-C-11"># </a>互斥信号量 (C++ 11)</h2><h3 id="mutex"><a class="header-anchor" href="#mutex"># </a>mutex</h3><pre><code class="language-cpp">class Foo {private:    mutex m1, m2;public:    Foo() {        m1.lock();        m2.lock();    }    void first(function&lt;void()&gt; printFirst) {        // printFirst() outputs &quot;first&quot;. Do not change or remove this line.        printFirst();        m1.unlock();    }    void second(function&lt;void()&gt; printSecond) {        m1.lock();        // printSecond() outputs &quot;second&quot;. Do not change or remove this line.        printSecond();        m2.unlock();    }    void third(function&lt;void()&gt; printThird) {        m2.lock();        // printThird() outputs &quot;third&quot;. Do not change or remove this line.        printThird();    }};</code></pre><h3 id="lock-guard-mutex"><a class="header-anchor" href="#lock-guard-mutex"># </a>lock_guard&lt;mutex&gt;</h3><pre><code class="language-cpp">#include &lt;mutex&gt;class Foo {private:    mutex m1, m2;public:    Foo() {        m1.lock();        m2.lock();    }    void first(function&lt;void()&gt; printFirst) {        // printFirst() outputs &quot;first&quot;. Do not change or remove this line.        printFirst();        m1.unlock();    }    void second(function&lt;void()&gt; printSecond) {        lock_guard&lt;mutex&gt; lk(m1);        // printSecond() outputs &quot;second&quot;. Do not change or remove this line.        printSecond();        m2.unlock();    }    void third(function&lt;void()&gt; printThird) {        lock_guard&lt;mutex&gt; lk(m2);        // printThird() outputs &quot;third&quot;. Do not change or remove this line.        printThird();    }};</code></pre><h2 id="原子-C-11"><a class="header-anchor" href="#原子-C-11"># </a>原子 (C++ 11)</h2><h3 id="atomic-flag"><a class="header-anchor" href="#atomic-flag"># </a>atomic_flag</h3><pre><code class="language-cpp">class Foo {    atomic_flag f1, f2;public:    Foo() {        f1.test_and_set(memory_order_acquire);        f2.test_and_set(memory_order_acquire);    }    void first(function&lt;void()&gt; printFirst) {                // printFirst() outputs &quot;first&quot;. Do not change or remove this line.        printFirst();        f1.clear(memory_order_release);    }    void second(function&lt;void()&gt; printSecond) {        while (f1.test_and_set(memory_order_acquire));        // printSecond() outputs &quot;second&quot;. Do not change or remove this line.        printSecond();        f2.clear(memory_order_release);    }    void third(function&lt;void()&gt; printThird) {        while (f2.test_and_set(memory_order_acquire));        // printThird() outputs &quot;third&quot;. Do not change or remove this line.        printThird();    }};</code></pre><h3 id="atomic-bool"><a class="header-anchor" href="#atomic-bool"># </a>atomic_bool</h3><pre><code class="language-cpp">class Foo {    atomic_bool b1, b2;public:    Foo() {        b1 = false;        b2 = false;    }    void first(function&lt;void()&gt; printFirst) {                // printFirst() outputs &quot;first&quot;. Do not change or remove this line.        printFirst();        b1 = true;    }    void second(function&lt;void()&gt; printSecond) {        while (!b1);        // printSecond() outputs &quot;second&quot;. Do not change or remove this line.        printSecond();        b2 = true;    }    void third(function&lt;void()&gt; printThird) {        while (!b2);        // printThird() outputs &quot;third&quot;. Do not change or remove this line.        printThird();    }};</code></pre><h1 id="1115-Bar"><a class="header-anchor" href="#1115-Bar"># </a>1115 Bar</h1><p><a href="https://leetcode-cn.com/problems/print-foobar-alternately/" target="_blank" rel="noopener">传送门</a></p><pre><code class="language-cpp">class FooBar {private:    int n;    mutex m1,m2;public:    FooBar(int n) {        this-&gt;n = n;        m1.lock();        m2.unlock();    }    void foo(function&lt;void()&gt; printFoo) {        for (int i = 0; i &lt; n; i++) {            m2.lock();            // printFoo() outputs &quot;foo&quot;. Do not change or remove this line.            printFoo();            m1.unlock();        }    }    void bar(function&lt;void()&gt; printBar) {        for (int i = 0; i &lt; n; i++) {            m1.lock();            // printBar() outputs &quot;bar&quot;. Do not change or remove this line.            printBar();            m2.unlock();        }    }};</code></pre><h1 id="1116-打印零与奇偶数"><a class="header-anchor" href="#1116-打印零与奇偶数"># </a>1116 打印零与奇偶数</h1><p><a href="https://leetcode-cn.com/problems/print-zero-even-odd/" target="_blank" rel="noopener">传送门</a></p><pre><code class="language-cpp">class ZeroEvenOdd {private:    int n;    mutex z,e,o;public:    ZeroEvenOdd(int n) {        this-&gt;n = n;        z.unlock();        e.lock();        o.lock();    }    // printNumber(x) outputs &quot;x&quot;, where x is an integer.    void zero(function&lt;void(int)&gt; printNumber) {        for(int i=1;i&lt;=n;i++){            z.lock();            printNumber(0);            if(i%2)o.unlock();            else e.unlock();        }    }    void even(function&lt;void(int)&gt; printNumber) {        for(int i=2;i&lt;=n;i+=2){            e.lock();            printNumber(i);            z.unlock();        }    }    void odd(function&lt;void(int)&gt; printNumber) {        for(int i=1;i&lt;=n;i+=2){            o.lock();            printNumber(i);            z.unlock();        }    }};</code></pre><h1 id="1117-H2O-生成"><a class="header-anchor" href="#1117-H2O-生成"># </a>1117 H2O 生成</h1><p><a href="https://leetcode-cn.com/problems/building-h2o/" target="_blank" rel="noopener">传送门</a></p><pre><code class="language-cpp">#include &lt;semaphore.h&gt;class H2O {private:    sem_t h,o;    int cnt;public:    H2O() {        sem_init(&amp;h, 0, 2);        sem_init(&amp;o, 0, 1);        cnt=0;    }    void hydrogen(function&lt;void()&gt; releaseHydrogen) {        sem_wait(&amp;h);        // releaseHydrogen() outputs &quot;H&quot;. Do not change or remove this line.        releaseHydrogen();        cnt++;        if(cnt==2){            sem_post(&amp;o);            cnt=0;        }    }    void oxygen(function&lt;void()&gt; releaseOxygen) {        sem_wait(&amp;o);        // releaseOxygen() outputs &quot;O&quot;. Do not change or remove this line.        releaseOxygen();        sem_post(&amp;h);        sem_post(&amp;h);    }};</code></pre><h1 id="1195-交替打印字符串"><a class="header-anchor" href="#1195-交替打印字符串"># </a>1195 交替打印字符串</h1><p><a href="https://leetcode-cn.com/problems/fizz-buzz-multithreaded/" target="_blank" rel="noopener">传送门</a></p><pre><code class="language-cpp">class FizzBuzz {private:    int n;    mutex f,b,fb,num;public:    FizzBuzz(int n) {        this-&gt;n = n;        f.lock();        b.lock();        fb.lock();    }    // printFizz() outputs &quot;fizz&quot;.    void fizz(function&lt;void()&gt; printFizz) {        for(int i=3;i&lt;=n;i+=3){            if(i%5==0)continue;            f.lock();            printFizz();            num.unlock();        }    }    // printBuzz() outputs &quot;buzz&quot;.    void buzz(function&lt;void()&gt; printBuzz) {        for(int i=5;i&lt;=n;i+=5){            if(i%3==0)continue;            b.lock();            printBuzz();            num.unlock();        }    }    // printFizzBuzz() outputs &quot;fizzbuzz&quot;.    void fizzbuzz(function&lt;void()&gt; printFizzBuzz) {        for(int i=15;i&lt;=n;i+=15){            fb.lock();            printFizzBuzz();            num.unlock();        }    }    // printNumber(x) outputs &quot;x&quot;, where x is an integer.    void number(function&lt;void(int)&gt; printNumber) {        for(int i=1;i&lt;=n;i++){            num.lock();            if(i%3==0&amp;&amp;i%5==0)fb.unlock();            else if(i%3==0)f.unlock();            else if(i%5==0)b.unlock();            else {                printNumber(i);                num.unlock();            }        }    }};</code></pre><h1 id="1226-哲学家进餐"><a class="header-anchor" href="#1226-哲学家进餐"># </a>1226 哲学家进餐</h1><p><a href="https://leetcode-cn.com/problems/the-dining-philosophers/" target="_blank" rel="noopener">传送门</a><br>操作系统书上的例子<br>用一个信号量表示一只叉子，由这五个信号量构成信号量数组</p><pre><code class="language-cpp">class DiningPhilosophers {private:    mutex fork[5];public:    DiningPhilosophers() {            }    void wantsToEat(int philosopher,                    function&lt;void()&gt; pickLeftFork,                    function&lt;void()&gt; pickRightFork,                    function&lt;void()&gt; eat,                    function&lt;void()&gt; putLeftFork,                    function&lt;void()&gt; putRightFork) {        fork[philosopher].lock();        pickLeftFork();        fork[(philosopher+1)%5].lock();        pickRightFork();        eat();        putLeftFork();        fork[philosopher].unlock();        putRightFork();        fork[(philosopher+1)%5].unlock();    }};</code></pre><p>虽然通过提交了，但是存在缺陷，可能会造成<strong>死锁</strong>。假如五位哲学家同时饥饿而各自拿起左边的叉子时，就会使五个互斥信号量均被锁住，当他们再试图去拿右边的叉子时，都将因无叉子可拿而无限期地等待。<br>总共有<strong>三种</strong>解决方法：</p><h2 id="最多可允许四位哲学家同时进餐"><a class="header-anchor" href="#最多可允许四位哲学家同时进餐"># </a>最多可允许四位哲学家同时进餐</h2><p>至多只允许有四位哲学家同时去拿左边的叉子，最终能保证至少有一位哲学家能够进餐，并在用毕时能释放出他用过的两只叉子，从而使更多的哲学家能够进餐。</p><pre><code class="language-cpp">#include &lt;semaphore.h&gt;class DiningPhilosophers {private:    sem_t s,fork[5];public:    DiningPhilosophers() {        // 最多只允许4位同时进餐        sem_init(&amp;s,0,4);        // 叉子的信号量        for(int i=0;i&lt;5;i++){            sem_init(&amp;fork[i],0,1);        }    }    void wantsToEat(int philosopher,                    function&lt;void()&gt; pickLeftFork,                    function&lt;void()&gt; pickRightFork,                    function&lt;void()&gt; eat,                    function&lt;void()&gt; putLeftFork,                    function&lt;void()&gt; putRightFork) {        int l=philosopher,r=(philosopher+1)%5;        sem_wait(&amp;s);        sem_wait(&amp;fork[l]);        pickLeftFork();        sem_wait(&amp;fork[r]);        pickRightFork();        eat();        putLeftFork();        sem_post(&amp;fork[l]);        putRightFork();        sem_post(&amp;fork[r]);        sem_post(&amp;s);    }};</code></pre><blockquote><p>执行用时：224 ms<br>内存消耗：13.2 MB</p></blockquote><h2 id="同时拿左右两只叉子"><a class="header-anchor" href="#同时拿左右两只叉子"># </a>同时拿左右两只叉子</h2><p>仅当哲学家的左、右两只叉子均可用时，才允许他拿起叉子进餐。需要使用信号量集（AND型信号量）。<br>说实话我不知道这个AND型信号量要怎么同时拿叉子，书上写的Sswait也是一个for循环按顺序控制，如果同时处理Sswait的话感觉还是解决不了五人同时相吃饭的问题（因为左右两个叉子的信号量都是1，同时拿的操作其实还是按顺序的，先拿左再拿右，如果五个人左边都拿了，那么右边就都死锁了）。<br>所以我多设置了一个信号量，当两只叉子都被拿起的时候，只能允许最多<strong>两个人</strong>同时进餐。</p><pre><code class="language-cpp">#include &lt;semaphore.h&gt;class DiningPhilosophers {private:    sem_t fork[5],s;public:    DiningPhilosophers() {        // 如果同时拿起两只叉子的话，可以同时有两个人进餐        sem_init(&amp;s,0,2);        // 当且仅当两只叉子均可用的时候，可以进餐        sem_init(&amp;s,0,1);        for(int i=0;i&lt;5;i++){            sem_init(&amp;fork[i],0,1);        }    }        // AND 型信号量    void Sswait(sem_t left,sem_t right){        int lval,rval;        sem_getvalue(&amp;left,&amp;lval);        sem_getvalue(&amp;right,&amp;rval);        if(lval==1&amp;&amp;rval==1){            sem_wait(&amp;s);            sem_wait(&amp;left);            sem_wait(&amp;right);        }    }    void wantsToEat(int philosopher,                    function&lt;void()&gt; pickLeftFork,                    function&lt;void()&gt; pickRightFork,                    function&lt;void()&gt; eat,                    function&lt;void()&gt; putLeftFork,                    function&lt;void()&gt; putRightFork) {        int l=philosopher,r=(philosopher+1)%5;        Sswait(fork[l],fork[r]);        pickLeftFork();        pickRightFork();        eat();        putLeftFork();        sem_post(&amp;fork[l]);        putRightFork();        sem_post(&amp;fork[r]);        sem_post(&amp;s);    }};</code></pre><blockquote><p>执行用时：204 ms<br>内存消耗：13.4 MB</p></blockquote><h2 id="先拿奇数号叉子，再拿偶数号叉子"><a class="header-anchor" href="#先拿奇数号叉子，再拿偶数号叉子"># </a>先拿奇数号叉子，再拿偶数号叉子</h2><p>规定奇数号哲学家先拿他左边的叉子，然后再去拿右边的叉子，而偶数号哲学家则相反。即五位哲学家都先竞争奇数号叉子，获得后，再去竞争偶数号叉子，最后总会有一位哲学家能获得两只叉子而进餐。</p><pre><code class="language-cpp">class DiningPhilosophers {private:    mutex fork[5];public:    DiningPhilosophers() {    }    void wantsToEat(int philosopher,                    function&lt;void()&gt; pickLeftFork,                    function&lt;void()&gt; pickRightFork,                    function&lt;void()&gt; eat,                    function&lt;void()&gt; putLeftFork,                    function&lt;void()&gt; putRightFork) {        int l=philosopher,r=(philosopher+1)%5;        if(philosopher%2){            fork[l].lock();            pickLeftFork();            fork[r].lock();            pickRightFork();        }else{            fork[r].lock();            pickRightFork();            fork[l].lock();            pickLeftFork();        }        eat();        putLeftFork();        fork[l].unlock();        putRightFork();        fork[r].unlock();    }};</code></pre><blockquote><p>执行用时：212 ms<br>内存消耗：13.6 MB</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Windows 10 上安装 CUDA 10.0</title>
      <link href="/2020/03/InstallCUDA10/"/>
      <url>/2020/03/InstallCUDA10/</url>
      
        <content type="html"><![CDATA[<p>因为有<a href="https://docs.nvidia.com/cuda/archive/10.0/cuda-installation-guide-microsoft-windows/index.html" target="_blank" rel="noopener">官方文档</a>了，所以就记录一点和文档不一样的地方</p><h1 id="验证安装"><a class="header-anchor" href="#验证安装"># </a>验证安装</h1><p><code>deviceQuery.exe</code>和<code>bandwidthTest.exe</code>的地址我的是在<code>NVIDIA GPU Computing Toolkit\CUDA\v10.0\extras\demo_suite</code></p><h1 id="在-Visual-Studio-2019-中运行-CUDA-项目"><a class="header-anchor" href="#在-Visual-Studio-2019-中运行-CUDA-项目"># </a>在 Visual Studio 2019 中运行 CUDA 项目</h1><p>因为时间的原因，在 CUDA 10.0 发布的时候并没有 Visual Studio 2019 这个东西，所以它给的示例工程只到了 Visual Studio 2017 版本，直接运行会报错，提示找不到<code>CUDA 10.0.props</code>这个文件<br>经过一阵查找，我找到了它在<code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.0\extras\visual_studio_integration\MSBuildExtensions</code>，尽管我的<code>CUDA</code>安装在了D盘<br>这时候我们只需要将<code>CUDA 10.0.props</code>以及和它在一个文件夹里的文件复制到报错的那个文件夹里就行了<br>现在可以打开解决方案了，会提示<code>若要使用 Visual Studio 2019 (v142) 生成工具进行生成，请单击&quot;项目&quot;菜单或右键单击解决方案，然后选择&quot;重定向解决方案...&quot;。安装 Visual Studio 2017 (v141) 可使用 Visual Studio 2017 (v141) 生成工具进行生成。</code><br>如果我们使用 Visual Studio 2019 (v142) 进行生成，会报错<code>#error:  -- unsupported Microsoft Visual Studio version! Only the versions between 2013 and 2017 (inclusive) are supported!</code>，所以我们应该安装 Visual Studio 2017 (v141)，然后在属性集中把<strong>平台工具集</strong>修改为 Visual Studio 2017 (v141)</p><h1 id="OpenGL-的安装"><a class="header-anchor" href="#OpenGL-的安装"># </a>OpenGL 的安装</h1><p>在翻 CUDA 的文件夹的时候发现了 freeglut 和 glew，那就顺便安装一下 OpenGL 好了。我的 C++ IDE 是 JetBrains 的 CLion，采用 MinGW-w64 环境<br>首先先找到 freeglut 和 glew 的 <code>.h</code> <code>.lib</code> <code>.dll</code> 的位置<br>我的<code>.h</code>文件在<code>NVIDIA GPU Computing Toolkit/CUDA Samples/v10.0/common/inc/GL</code>，<code>.lib</code>文件在<code>NVIDIA GPU Computing Toolkit\CUDA Samples\v10.0\common\lib\x64</code>，<code>.dll</code>在<code>NVIDIA GPU Computing Toolkit\CUDA Samples\v10.0\bin\win64\Release</code>和<code>NVIDIA GPU Computing Toolkit\CUDA\v10.0\extras\demo_suite</code>下都有，但它们大小是一样的，随便选择就行了<br>把<code>.dll</code>移动到<code>C:\Windows\System32</code>和<code>C:\Windows\SysWOW64</code>下<br>因为<code>NVIDIA GPU Computing Toolkit</code>路径中含有空格，在 CMakeLists.txt 中<code>link_directories</code>和<code>include_directories</code>引入时需要将空格转义<code>\ </code></p><pre><code class="language-cmake">link_directories(D:/Program/NVIDIA\ GPU\ Computing\ Toolkit/CUDA\ Samples/v10.0/common/lib/x64)include_directories(D:/Program/NVIDIA\ GPU\ Computing\ Toolkit/CUDA/v10.0/extras/CUPTI/include)include_directories(D:/Program/NVIDIA\ GPU\ Computing\ Toolkit/CUDA\ Samples/v10.0/common/inc)</code></pre><p>然后添加需要编译的 cpp，并和<code>.lib</code>链接起来</p><pre><code class="language-cmake">add_executable(YOUR_PROJECT_NAME main.cpp)target_link_libraries(YOUR_PROJECT_NAME -lopengl32 -lglu32 freeglut.lib glew64.lib)</code></pre><blockquote><p>这里的<code>opengl32</code>和<code>glu32</code>是必要的，不然会报错</p></blockquote><p>运行后，我的程序出现了报错，<code>#include&lt;GL/gl.h&gt;</code>出错了，因为有<code>freeglut.h</code>的文件夹中并没有<code>gl.h</code>和<code>glu.h</code>，我在<code>NVIDIA GPU Computing Toolkit\CUDA\v10.0\extras\CUPTI\include\GL</code>中找到了这两个文件，将他们移动到了<code>D:\Tool\mingw64\include\GL</code>中，再次运行就没有报错了<br>附上一个测试程序，这个是我上计算机图形学时配 OpenGL 自动生成的示例程序</p><pre><code class="language-cpp">/* * GLUT Shapes Demo * * Written by Nigel Stewart November 2003 * * This program is test harness for the sphere, cone * and torus shapes in GLUT. * * Spinning wireframe and smooth shaded shapes are * displayed until the ESC or q key is pressed.  The * number of geometry stacks and slices can be adjusted * using the + and - keys. *//* 这里使用freeglut.h，而不是glut.h */#include &lt;GL/freeglut.h&gt;#include &lt;stdlib.h&gt;static int slices = 16;static int stacks = 16;/* GLUT callback Handlers */static void resize(int width, int height){    const float ar = (float) width / (float) height;    glViewport(0, 0, width, height);    glMatrixMode(GL_PROJECTION);    glLoadIdentity();    glFrustum(-ar, ar, -1.0, 1.0, 2.0, 100.0);    glMatrixMode(GL_MODELVIEW);    glLoadIdentity() ;}static void display(void){    const double t = glutGet(GLUT_ELAPSED_TIME) / 1000.0;    const double a = t*90.0;    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);    glColor3d(1,0,0);    glPushMatrix();        glTranslated(-2.4,1.2,-6);        glRotated(60,1,0,0);        glRotated(a,0,0,1);        glutSolidSphere(1,slices,stacks);    glPopMatrix();    glPushMatrix();        glTranslated(0,1.2,-6);        glRotated(60,1,0,0);        glRotated(a,0,0,1);        glutSolidCone(1,1,slices,stacks);    glPopMatrix();    glPushMatrix();        glTranslated(2.4,1.2,-6);        glRotated(60,1,0,0);        glRotated(a,0,0,1);        glutSolidTorus(0.2,0.8,slices,stacks);    glPopMatrix();    glPushMatrix();        glTranslated(-2.4,-1.2,-6);        glRotated(60,1,0,0);        glRotated(a,0,0,1);        glutWireSphere(1,slices,stacks);    glPopMatrix();    glPushMatrix();        glTranslated(0,-1.2,-6);        glRotated(60,1,0,0);        glRotated(a,0,0,1);        glutWireCone(1,1,slices,stacks);    glPopMatrix();    glPushMatrix();        glTranslated(2.4,-1.2,-6);        glRotated(60,1,0,0);        glRotated(a,0,0,1);        glutWireTorus(0.2,0.8,slices,stacks);    glPopMatrix();    glutSwapBuffers();}static void key(unsigned char key, int x, int y){    switch (key)    {        case 27 :        case 'q':            exit(0);            break;        case '+':            slices++;            stacks++;            break;        case '-':            if (slices&gt;3 &amp;&amp; stacks&gt;3)            {                slices--;                stacks--;            }            break;    }    glutPostRedisplay();}static void idle(void){    glutPostRedisplay();}const GLfloat light_ambient[]  = { 0.0f, 0.0f, 0.0f, 1.0f };const GLfloat light_diffuse[]  = { 1.0f, 1.0f, 1.0f, 1.0f };const GLfloat light_specular[] = { 1.0f, 1.0f, 1.0f, 1.0f };const GLfloat light_position[] = { 2.0f, 5.0f, 5.0f, 0.0f };const GLfloat mat_ambient[]    = { 0.7f, 0.7f, 0.7f, 1.0f };const GLfloat mat_diffuse[]    = { 0.8f, 0.8f, 0.8f, 1.0f };const GLfloat mat_specular[]   = { 1.0f, 1.0f, 1.0f, 1.0f };const GLfloat high_shininess[] = { 100.0f };/* Program entry point */int main(int argc, char *argv[]){    glutInit(&amp;argc, argv);    glutInitWindowSize(640,480);    glutInitWindowPosition(10,10);    glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH);    glutCreateWindow(&quot;GLUT Shapes&quot;);    glutReshapeFunc(resize);    glutDisplayFunc(display);    glutKeyboardFunc(key);    glutIdleFunc(idle);    glClearColor(1,1,1,1);    glEnable(GL_CULL_FACE);    glCullFace(GL_BACK);    glEnable(GL_DEPTH_TEST);    glDepthFunc(GL_LESS);    glEnable(GL_LIGHT0);    glEnable(GL_NORMALIZE);    glEnable(GL_COLOR_MATERIAL);    glEnable(GL_LIGHTING);    glLightfv(GL_LIGHT0, GL_AMBIENT,  light_ambient);    glLightfv(GL_LIGHT0, GL_DIFFUSE,  light_diffuse);    glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);    glLightfv(GL_LIGHT0, GL_POSITION, light_position);    glMaterialfv(GL_FRONT, GL_AMBIENT,   mat_ambient);    glMaterialfv(GL_FRONT, GL_DIFFUSE,   mat_diffuse);    glMaterialfv(GL_FRONT, GL_SPECULAR,  mat_specular);    glMaterialfv(GL_FRONT, GL_SHININESS, high_shininess);    glutMainLoop();    return EXIT_SUCCESS;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 没有官方文档重要的教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA 10.0 </tag>
            
            <tag> nVidia </tag>
            
            <tag> Windows 10 </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一份 Windows Terminal 配置笔记</title>
      <link href="/2020/02/BeautifyWindowsTerminal/"/>
      <url>/2020/02/BeautifyWindowsTerminal/</url>
      
        <content type="html"><![CDATA[<!-- toc --><p><a href="https://github.com/microsoft/terminal" target="_blank" rel="noopener">Windows Terminal 的 github 传送门</a></p><h1 id="安装-Windows-Terminal"><a class="header-anchor" href="#安装-Windows-Terminal"># </a>安装 Windows Terminal</h1><p>到 <a href="https://www.microsoft.com/zh-cn/p/windows-terminal-preview/9n0dx20hk701?ocid=AID681541_aff_7593_1243925" target="_blank" rel="noopener">Microsoft Store</a> 就能安装啦！</p><h1 id="Profiles-json"><a class="header-anchor" href="#Profiles-json"># </a>Profiles.json</h1><p>Windows Terminal 的配置都在这里面，通过修改这里面的参数就能自定义自己的 Windows Terminal 啦！<br><a href="https://github.com/microsoft/terminal/blob/master/doc/cascadia/SettingsSchema.md" target="_blank" rel="noopener">Profiles.json 的参数说明</a><br>先放一份我自己的效果图😝</p><p><img src="/2020/02/BeautifyWindowsTerminal/color.png" alt="color"></p><p>接下来就开始讲配置啦！</p><h2 id="背景"><a class="header-anchor" href="#背景"># </a>背景</h2><p>背景可以设置背景图片，但是我没有。我只是使用了<code>useAcrylic</code>和<code>acrylicOpacity</code>开启了毛玻璃效果而已。背景颜色在接下来要讲的<code>Schemes</code>中的<code>background</code>中设置。</p><h2 id="配色"><a class="header-anchor" href="#配色"># </a>配色</h2><p>通过 <a href="https://github.com/microsoft/terminal/blob/master/doc/cascadia/SettingsSchema.md#Schemes" target="_blank" rel="noopener"><code>Schemes</code></a> 设置自己喜欢的配色，然后在<code>name</code>中取上一个名字，就可以通过<code>colorScheme</code>调用啦！<br>在<a href="https://github.com/mbadolato/iTerm2-Color-Schemes/tree/master/windowsterminal" target="_blank" rel="noopener">iTerm2</a>中已经有一些现成的配色方案了，直接使用就可以了。<br>我使用的是修改后的<code>OneHalfLight</code>，将白色修改成了灰色，避免看不清的情况。同时还修改了光标的颜色<code>cursorColor</code>。</p><pre><code class="language-json">{  &quot;profiles&quot;: [    {      &quot;colorScheme&quot;: &quot;OneHalfLight&quot;,      &quot;cursorColor&quot;: &quot;#7A8181&quot;    }  ],  &quot;schemes&quot;: [    {      &quot;name&quot;: &quot;OneHalfLight&quot;,      &quot;black&quot;: &quot;#383a42&quot;,      &quot;red&quot;: &quot;#e45649&quot;,      &quot;green&quot;: &quot;#4876D6&quot;,      &quot;yellow&quot;: &quot;#c18401&quot;,      &quot;blue&quot;: &quot;#0184bc&quot;,      &quot;purple&quot;: &quot;#a626a4&quot;,      &quot;cyan&quot;: &quot;#0997b3&quot;,      &quot;white&quot;: &quot;#7A8181&quot;,      &quot;brightBlack&quot;: &quot;#4f525e&quot;,      &quot;brightRed&quot;: &quot;#e06c75&quot;,      &quot;brightGreen&quot;: &quot;#98c379&quot;,      &quot;brightYellow&quot;: &quot;#e5c07b&quot;,      &quot;brightBlue&quot;: &quot;#61afef&quot;,      &quot;brightPurple&quot;: &quot;#c678dd&quot;,      &quot;brightCyan&quot;: &quot;#56b6c2&quot;,      &quot;brightWhite&quot;: &quot;#989FB1&quot;,      &quot;background&quot;: &quot;#fafafa&quot;,      &quot;foreground&quot;: &quot;#383a42&quot;    }  ]}</code></pre><h2 id="字体"><a class="header-anchor" href="#字体"># </a>字体</h2><p>字体可以通过<code>font-face</code>进行更改，但只能设置一个字体。如果想要同时拥有喜欢的英文等宽字体和中文等宽字体的话，可以使用<a href="https://github.com/nowar-fonts/Warcraft-Font-Merger" target="_blank" rel="noopener">WFM</a>进行合成。<br>我使用的是<code>Consolas</code>和<code>Source Han Sans SC</code>（思源宋体）的混合字体。</p><h2 id="更多Tab"><a class="header-anchor" href="#更多Tab"># </a>更多Tab</h2><p>在<code>profiles</code>中，一个字典代表着一个选项窗口，可以通过设置<code>commandline</code>设置不同的命令得到不同便捷的选项窗口。<br>我目前的选项窗口有这些👇</p><p><img src="/2020/02/BeautifyWindowsTerminal/tab.png" alt="tab"></p><p>以图中的iPython为例子，这是配置字典👇</p><pre><code class="language-json">{      &quot;guid&quot;: &quot;{9434E8AE-D1E1-4F63-B8F7-F6F7DACD0C02}&quot;,      &quot;hidden&quot;: false,      &quot;name&quot;: &quot;IPython&quot;,      &quot;commandline&quot;: &quot;ipython&quot;,      &quot;acrylicOpacity&quot;: 0.75,      &quot;useAcrylic&quot;: true,      &quot;closeOnExit&quot;: true,      &quot;fontFace&quot;: &quot;Consolas + Source Han Sans SC&quot;,      &quot;colorScheme&quot;: &quot;OneHalfLight&quot;,      &quot;tabTitle&quot;: &quot;IPython&quot;,      &quot;icon&quot;: &quot;D:/Picture/Icon/python-144.png&quot;,      &quot;cursorColor&quot;: &quot;#7A8181&quot;,      &quot;cursorShape&quot;: &quot;bar&quot;,      &quot;startingDirectory&quot;: null}</code></pre><p>能启动 iPython 的原因就是我在<code>commandline</code>中设置了<code>ipython</code>。如果你在<code>Powershell</code>中输入<code>ipython</code>可以启动 iPython 的话，那么这个窗口你就可以开启。<br>每个选项窗口会有一个<code>guid</code>，这个可以随机生成，或者是通过<code>Visual Studio</code>中的工具 → 创建GUID 进行生成，你可以在全局中更改<code>defaultProfile</code>的 GUID 进行默认启动窗口的设置。<br>我的 iPython 效果图👇</p><p><img src="/2020/02/BeautifyWindowsTerminal/ipython.png" alt="ipython"></p><h2 id="默认大小"><a class="header-anchor" href="#默认大小"># </a>默认大小</h2><p>在全局中（也就是<code>profiles</code>之前）设置<code>initialCols</code>和<code>initialRows</code>可以设置默认大小，我的设置为<code>90</code>和<code>30</code>。</p><h1 id="在当前文件夹中右键选择打开-Windows-Terminal"><a class="header-anchor" href="#在当前文件夹中右键选择打开-Windows-Terminal"># </a>在当前文件夹中右键选择打开 Windows Terminal</h1><p><code>cd</code>很麻烦，有的时候我们希望可以像<code>Git Bash Here</code>那样，在文件夹内右键就可以打开终端使用，这个通过修改注册表就可以完成。<br>我们先将<code>Profiles.json</code>中的<code>startingDirectory</code>设置成<code>null</code>。<br>然后创建一个<code>.reg</code>的文件，填写以下代码</p><pre><code class="language-powershell">Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\Directory\Background\shell\wt]@=&quot;Windows Terminal Here&quot;&quot;Icon&quot;=&quot;[YOUR ICON PATH]&quot;[HKEY_CLASSES_ROOT\Directory\Background\shell\wt\command]@=&quot;C:\\Users\\[YOURNAME]\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe&quot;</code></pre><blockquote><p>Windows Terminal 的 Icon 可以在<a href="https://github.com/microsoft/terminal/blob/master/res/terminal.ico" target="_blank" rel="noopener">它的 github</a> 中找到</p></blockquote><p>然后运行。打开文件夹，按右键</p><p><img src="/2020/02/BeautifyWindowsTerminal/here.png" alt="here"></p><p>完成！</p>]]></content>
      
      
      <categories>
          
          <category> 搞点什么东东吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows Terminal </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用阿里云ECS配置MongoDB集群</title>
      <link href="/2019/09/Aliyun-MongoDBCluster/"/>
      <url>/2019/09/Aliyun-MongoDBCluster/</url>
      
        <content type="html"><![CDATA[<h1 id="需要准备的东西"><a class="header-anchor" href="#需要准备的东西"># </a>需要准备的东西</h1><p>三台同一地域的阿里云学生机（Ubuntu 18.04.3），记住<strong>公网ip</strong>和<strong>私网ip</strong>以及服务器的<strong>主机名</strong>。</p><h1 id="Step-1-内网互通"><a class="header-anchor" href="#Step-1-内网互通"># </a>Step 1: 内网互通</h1><p>使用云企业网使内网互通，<strong>只需要一个云企业网</strong>，也就是只需要一台服务器建立云企业网，其他两台加入就好了。</p><blockquote><p>传送门：<a href="https://help.aliyun.com/document_detail/65901.html" target="_blank" rel="noopener">跨账号同地域网络实例互通</a></p></blockquote><p>三台机器都加入云企业网后，进入云企业网看<strong>路由信息</strong>，查看是否有冲突。<br><img src="/2019/09/Aliyun-MongoDBCluster/pic2.png" alt="pic2"><br>若有冲突，则需要修改导致冲突其中一方的私网ip并<strong>更换交换机</strong>。</p><blockquote><p>传送门：<a href="https://help.aliyun.com/document_detail/27733.html" target="_blank" rel="noopener">修改私网IP地址</a></p></blockquote><p>互相都能ping通的话，就说明配置好了。</p><h1 id="Step-2-安装MongoDB-4-2-0"><a class="header-anchor" href="#Step-2-安装MongoDB-4-2-0"># </a>Step 2: 安装MongoDB 4.2.0</h1><p>这里直接按官方文档操作就好了，apt或压缩包安装均可。</p><blockquote><p>传送门：<a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/" target="_blank" rel="noopener">Install MongoDB Community Edition on Ubuntu</a></p></blockquote><h1 id="Step-3-添加虚拟内存"><a class="header-anchor" href="#Step-3-添加虚拟内存"># </a>Step 3: 添加虚拟内存</h1><p>因为阿里云学生机只有2GiB RAM，但MongoDB Ops Manager需要15GB RAM，所以需要加虚拟内存。</p><p>查看RAM使用状态</p><pre><code class="language-bash">free -h</code></pre><p>查看硬盘使用状态</p><pre><code class="language-bash">df -h</code></pre><p>查看是否存在swapfile</p><pre><code class="language-bash">sudo swapon -s</code></pre><p>创建swapfile，我是直接开了16G。</p><pre><code class="language-bash">sudo fallocate -l 16G /swapfile</code></pre><p>初始化为swap</p><pre><code class="language-bash">sudo mkswap /swapfile</code></pre><p>挂载swapfile</p><pre><code class="language-bash">sudo swapon /swapfile</code></pre><p>使swapfile自动挂载</p><pre><code class="language-bash">echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab</code></pre><h1 id="Step-4-安装MongoDB-Ops-Manager-4-2-1"><a class="header-anchor" href="#Step-4-安装MongoDB-Ops-Manager-4-2-1"># </a>Step 4: 安装MongoDB Ops Manager 4.2.1</h1><p><strong>只需要一台机器安装</strong>！这里使用DEB包安装的方式。</p><blockquote><p>传送门：<a href="https://docs.opsmanager.mongodb.com/current/tutorial/install-on-prem-with-deb-packages/" target="_blank" rel="noopener">Install Ops Manager with a deb Package</a></p></blockquote><blockquote><p>其中第三步，<code>mongo.mongoUri</code>只需填一台机器（当前机器）的<strong>私网</strong>和用于存储日志等的数据库<strong>端口</strong>。不采用https的话，<code>mongo.ssl</code>填<code>False</code>。</p></blockquote><p>启动mongodb-mms.sercive是一个漫长的过程，可以<code>sudo systemctl status mongodb-mms.service</code>查看启动状态，或是启动时使用命令<code>sudo /etc/init.d/mongodb-mms.service start</code>。<br>能访问<code>http://&lt;外网ip&gt;:8080</code>就ok了，然后就注册和配置就好了。</p><blockquote><p><code>URL To Access Ops Manager</code>填<code>http://&lt;私网ip&gt;:8080</code>，这样速度会快。</p></blockquote><blockquote><p><code>Installer Download Source</code>选<code>Ops Manager Application Server</code>，下面一个下拉框选<code>Ops Manager Application Server Hard Driver</code>。<br>意思就是从本机下载MongoDB，而不是从MongoDB源。然后把mongodb4.2.0的tgz压缩包放到当前机器的<code>/opt/mongodb/mms/mongodb-releases/</code>文件夹（就是<code>Versions Directory</code>填的文件夹）下。</p></blockquote><h1 id="Step-5-修改主机名"><a class="header-anchor" href="#Step-5-修改主机名"># </a>Step 5: 修改主机名</h1><p><strong>每台机器都要修改！</strong><br>打开<code>/etc/hosts</code>修改主机名，如果文件提示Readonly，那么执行<code>chmod 644 /etc/hosts</code>赋予权限。<br>在开头添加以下形式的内容：</p><pre><code>私网ip1 主机名1私网ip2 主机名2私网ip3 主机名3</code></pre><p><img src="/2019/09/Aliyun-MongoDBCluster/pic3.png" alt="pic3"></p><blockquote><p>一个主机名只能对应一个私网ip！</p></blockquote><h1 id="Step-6-安装MongoDB-Agent"><a class="header-anchor" href="#Step-6-安装MongoDB-Agent"># </a>Step 6: 安装MongoDB Agent</h1><p><strong>每台机器都要安装！</strong><br>Agents -&gt; Downloads &amp; Settings -&gt; 下拉框选择系统 -&gt; 选择<code>Debian 8/9, Ubuntu 16.x/18.x - DEB</code>，然后按步骤安装即可。<br><img src="/2019/09/Aliyun-MongoDBCluster/pic1.png" alt="pic1"></p><blockquote><p>注意要保存好<code>Agent API Key</code>，因为在教程页面只出现一次！</p></blockquote><p><code>sudo systemctl status mongodb-mms-automation-agent.service</code>查看启动状态，没有failed通常来说就是ok了。</p><h1 id="Step-7-新建集群"><a class="header-anchor" href="#Step-7-新建集群"># </a>Step 7: 新建集群</h1><p>Add New -&gt; New Sharded Cluster，自行配置就好了，但是注意<strong>端口</strong>还有<strong>地址</strong>不要冲突，且<strong>在阿里云内需要开端口</strong>。如果之前配置都对的话，是很快就会建好的。<br><img src="/2019/09/Aliyun-MongoDBCluster/pic6.png" alt="pic6"></p><blockquote><p>如果提示<strong>权限</strong>错误的话，就检查一下<code>/data</code>文件夹的权限。</p></blockquote><blockquote><p>如果提示<strong>网络通信</strong>间的错误的话，就检查一下<code>/etc/hosts</code>文件的ip和主机名的对应关系，还有端口是否都开了。如果相互之间<code>mongo &lt;主机名&gt;:&lt;端口&gt;</code>能连上，基本就没问题了。</p></blockquote><h1 id="Step-8-插入数据"><a class="header-anchor" href="#Step-8-插入数据"># </a>Step 8: 插入数据</h1><ul><li>用Ops Manager可以插入单条数据</li><li>用NoSQLBooster连接集群，用Import可以通过文件插入多条数据</li></ul><blockquote><p>连接NoSQLBooster时，需要在本机修改hosts文件。<br>Windows的文件位置在<code>C:\Windows\System32\drivers\etc\hosts</code>，像Step 5一样添加内容（<strong>私网ip要改成公网ip</strong>）就好了。配置好了是可以通过<code>&lt;主机名&gt;:&lt;端口&gt;</code>连上的。<br><img src="/2019/09/Aliyun-MongoDBCluster/pic5.png" alt="pic5"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 没有官方文档重要的教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阿里云ECS </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 使用 KaTeX 渲染数学公式</title>
      <link href="/2019/07/HexoKatex/"/>
      <url>/2019/07/HexoKatex/</url>
      
        <content type="html"><![CDATA[<h1 id="说点话"><a class="header-anchor" href="#说点话"># </a>_说点话</h1><p>保留了Hexo默认的Markdown渲染器<a href="https://github.com/hexojs/hexo-renderer-marked" target="_blank" rel="noopener">hexo-renderer-marked</a>，采用<a href="https://github.com/hexojs/hexo-math" target="_blank" rel="noopener">hexo-math</a>中的<a href="https://katex.org/" target="_blank" rel="noopener">KaTeX</a>引擎对数学公式进行渲染。</p><h1 id="食用方式"><a class="header-anchor" href="#食用方式"># </a>_食用方式</h1><h2 id="01-安装hexo-math"><a class="header-anchor" href="#01-安装hexo-math"># </a>01 安装hexo-math</h2><pre><code class="language-batch">npm install hexo-math --save</code></pre><h2 id="02-配置hexo-math"><a class="header-anchor" href="#02-配置hexo-math"># </a>02 配置hexo-math</h2><p>打开根目录下的<code>_config.yml</code>，添加</p><pre><code class="language-yaml">plugin:  - hexo-math</code></pre><pre><code class="language-yaml">math:  engine: 'katex'  katex:    css: https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css    js: https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.js    config:      # KaTeX config</code></pre><h2 id="03-重启Hexo"><a class="header-anchor" href="#03-重启Hexo"># </a>03 重启Hexo</h2><pre><code class="language-bash">hexo cleanhexo generatehexo server</code></pre><h2 id="04-更新-KaTeX"><a class="header-anchor" href="#04-更新-KaTeX"># </a>04 更新 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>KaTeX</mtext></mrow><annotation encoding="application/x-tex">\KaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89883em;vertical-align:-0.2155em;"></span><span class="mord text"><span class="mord textrm">K</span><span class="mspace" style="margin-right:-0.17em;"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.904999em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord text"><span class="mord textrm sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-0.15em;"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.46782999999999997em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span></span></h2><p><strong>本节在2020/03/01更新</strong>，因为有部分式子解析不成功，需要更新<br>进入<code>YOUR_BLOG_PATH\node_modules\hexo-math</code>文件夹，点击<code>package.json</code>可以看到</p><pre><code class="language-json">&quot;dependencies&quot;: {    &quot;html-entities&quot;: &quot;^1.1.3&quot;,    &quot;katex&quot;: &quot;^0.6.0&quot;  },</code></pre><p>表明它依赖的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>KaTeX</mtext></mrow><annotation encoding="application/x-tex">\KaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89883em;vertical-align:-0.2155em;"></span><span class="mord text"><span class="mord textrm">K</span><span class="mspace" style="margin-right:-0.17em;"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.904999em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord text"><span class="mord textrm sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-0.15em;"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.46782999999999997em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span></span>版本为<code>0.6.0</code>，而目前最新的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>KaTeX</mtext></mrow><annotation encoding="application/x-tex">\KaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89883em;vertical-align:-0.2155em;"></span><span class="mord text"><span class="mord textrm">K</span><span class="mspace" style="margin-right:-0.17em;"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.904999em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord text"><span class="mord textrm sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-0.15em;"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.46782999999999997em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span></span>版本为<code>0.11.1</code>，所以我们将<code>0.6.0</code>改为<code>0.11.1</code><br>同时需要在根目录下的<code>_config.yml</code>中把<code>css</code>和<code>js</code>中的版本改成最新的</p><pre><code class="language-json">&quot;dependencies&quot;: {    &quot;html-entities&quot;: &quot;^1.1.3&quot;,    &quot;katex&quot;: &quot;^0.11.1&quot;  },</code></pre><pre><code class="language-yaml">math:  engine: 'katex'  katex:    css: https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css    js: https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.js    config:      # KaTeX config</code></pre><h1 id="注意事项"><a class="header-anchor" href="#注意事项"># </a>_注意事项</h1><ul><li>css和js的cdn必须自定义，默认不可用</li><li><code>$...$</code> 和 <code>$$...$$</code> 需要被替换成 <code>math</code> 块</li><li>hexo-math也可以采用MathJax引擎，但速度慢且没有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>KaTeX</mtext></mrow><annotation encoding="application/x-tex">\KaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89883em;vertical-align:-0.2155em;"></span><span class="mord text"><span class="mord textrm">K</span><span class="mspace" style="margin-right:-0.17em;"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.904999em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord text"><span class="mord textrm sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-0.15em;"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.46782999999999997em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span></span>好看</li><li>最好参考官方文档食用</li></ul><h1 id="附录"><a class="header-anchor" href="#附录"># </a>_附录</h1><p><a href="https://katex.org/docs/supported.html" target="_blank" rel="noopener">KaTeX的食用文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 建站相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KaTeX </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
