<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用阿里云ECS配置MongoDB集群</title>
    <url>/2019/09/Aliyun-MongoDBCluster/</url>
    <content><![CDATA[<h1 id="需要准备的东西"><a class="header-anchor" href="#需要准备的东西"># </a>需要准备的东西</h1>
<p>三台同一地域的阿里云学生机（Ubuntu 18.04.3），记住<strong>公网ip</strong>和<strong>私网ip</strong>以及服务器的<strong>主机名</strong>。</p>
<h1 id="Step-1-内网互通"><a class="header-anchor" href="#Step-1-内网互通"># </a>Step 1: 内网互通</h1>
<p>使用云企业网使内网互通，<strong>只需要一个云企业网</strong>，也就是只需要一台服务器建立云企业网，其他两台加入就好了。</p>
<blockquote>
<p>传送门：<a href="https://help.aliyun.com/document_detail/65901.html" target="_blank" rel="noopener">跨账号同地域网络实例互通</a></p>
</blockquote>
<p>三台机器都加入云企业网后，进入云企业网看<strong>路由信息</strong>，查看是否有冲突。<br>
<img src="/2019/09/Aliyun-MongoDBCluster/pic2.png" alt="pic2"><br>
若有冲突，则需要修改导致冲突其中一方的私网ip并<strong>更换交换机</strong>。</p>
<blockquote>
<p>传送门：<a href="https://help.aliyun.com/document_detail/27733.html" target="_blank" rel="noopener">修改私网IP地址</a></p>
</blockquote>
<p>互相都能ping通的话，就说明配置好了。</p>
<h1 id="Step-2-安装MongoDB-4-2-0"><a class="header-anchor" href="#Step-2-安装MongoDB-4-2-0"># </a>Step 2: 安装MongoDB 4.2.0</h1>
<p>这里直接按官方文档操作就好了，apt或压缩包安装均可。</p>
<blockquote>
<p>传送门：<a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/" target="_blank" rel="noopener">Install MongoDB Community Edition on Ubuntu</a></p>
</blockquote>
<h1 id="Step-3-添加虚拟内存"><a class="header-anchor" href="#Step-3-添加虚拟内存"># </a>Step 3: 添加虚拟内存</h1>
<p>因为阿里云学生机只有2GiB RAM，但MongoDB Ops Manager需要15GB RAM，所以需要加虚拟内存。</p>
<p>查看RAM使用状态</p>
<pre><code class="language-bash">free -h
</code></pre>
<p>查看硬盘使用状态</p>
<pre><code class="language-bash">df -h
</code></pre>
<p>查看是否存在swapfile</p>
<pre><code class="language-bash">sudo swapon -s
</code></pre>
<p>创建swapfile，我是直接开了16G。</p>
<pre><code class="language-bash">sudo fallocate -l 16G /swapfile
</code></pre>
<p>初始化为swap</p>
<pre><code class="language-bash">sudo mkswap /swapfile
</code></pre>
<p>挂载swapfile</p>
<pre><code class="language-bash">sudo swapon /swapfile
</code></pre>
<p>使swapfile自动挂载</p>
<pre><code class="language-bash">echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab
</code></pre>
<h1 id="Step-4-安装MongoDB-Ops-Manager-4-2-1"><a class="header-anchor" href="#Step-4-安装MongoDB-Ops-Manager-4-2-1"># </a>Step 4: 安装MongoDB Ops Manager 4.2.1</h1>
<p><strong>只需要一台机器安装</strong>！这里使用DEB包安装的方式。</p>
<blockquote>
<p>传送门：<a href="https://docs.opsmanager.mongodb.com/current/tutorial/install-on-prem-with-deb-packages/" target="_blank" rel="noopener">Install Ops Manager with a deb Package</a></p>
</blockquote>
<blockquote>
<p>其中第三步，<code>mongo.mongoUri</code>只需填一台机器（当前机器）的<strong>私网</strong>和用于存储日志等的数据库<strong>端口</strong>。不采用https的话，<code>mongo.ssl</code>填<code>False</code>。</p>
</blockquote>
<p>启动mongodb-mms.sercive是一个漫长的过程，可以<code>sudo systemctl status mongodb-mms.service</code>查看启动状态，或是启动时使用命令<code>sudo /etc/init.d/mongodb-mms.service start</code>。<br>
能访问<code>http://&lt;外网ip&gt;:8080</code>就ok了，然后就注册和配置就好了。</p>
<blockquote>
<p><code>URL To Access Ops Manager</code>填<code>http://&lt;私网ip&gt;:8080</code>，这样速度会快。</p>
</blockquote>
<blockquote>
<p><code>Installer Download Source</code>选<code>Ops Manager Application Server</code>，下面一个下拉框选<code>Ops Manager Application Server Hard Driver</code>。<br>
意思就是从本机下载MongoDB，而不是从MongoDB源。然后把mongodb4.2.0的tgz压缩包放到当前机器的<code>/opt/mongodb/mms/mongodb-releases/</code>文件夹（就是<code>Versions Directory</code>填的文件夹）下。</p>
</blockquote>
<h1 id="Step-5-修改主机名"><a class="header-anchor" href="#Step-5-修改主机名"># </a>Step 5: 修改主机名</h1>
<p><strong>每台机器都要修改！</strong><br>
打开<code>/etc/hosts</code>修改主机名，如果文件提示Readonly，那么执行<code>chmod 644 /etc/hosts</code>赋予权限。<br>
在开头添加以下形式的内容：</p>
<pre><code>私网ip1 主机名1
私网ip2 主机名2
私网ip3 主机名3
</code></pre>
<p><img src="/2019/09/Aliyun-MongoDBCluster/pic3.png" alt="pic3"></p>
<blockquote>
<p>一个主机名只能对应一个私网ip！</p>
</blockquote>
<h1 id="Step-6-安装MongoDB-Agent"><a class="header-anchor" href="#Step-6-安装MongoDB-Agent"># </a>Step 6: 安装MongoDB Agent</h1>
<p><strong>每台机器都要安装！</strong><br>
Agents -&gt; Downloads &amp; Settings -&gt; 下拉框选择系统 -&gt; 选择<code>Debian 8/9, Ubuntu 16.x/18.x - DEB</code>，然后按步骤安装即可。<br>
<img src="/2019/09/Aliyun-MongoDBCluster/pic1.png" alt="pic1"></p>
<blockquote>
<p>注意要保存好<code>Agent API Key</code>，因为在教程页面只出现一次！</p>
</blockquote>
<p><code>sudo systemctl status mongodb-mms-automation-agent.service</code>查看启动状态，没有failed通常来说就是ok了。</p>
<h1 id="Step-7-新建集群"><a class="header-anchor" href="#Step-7-新建集群"># </a>Step 7: 新建集群</h1>
<p>Add New -&gt; New Sharded Cluster，自行配置就好了，但是注意<strong>端口</strong>还有<strong>地址</strong>不要冲突，且<strong>在阿里云内需要开端口</strong>。如果之前配置都对的话，是很快就会建好的。<br>
<img src="/2019/09/Aliyun-MongoDBCluster/pic6.png" alt="pic6"></p>
<blockquote>
<p>如果提示<strong>权限</strong>错误的话，就检查一下<code>/data</code>文件夹的权限。</p>
</blockquote>
<blockquote>
<p>如果提示<strong>网络通信</strong>间的错误的话，就检查一下<code>/etc/hosts</code>文件的ip和主机名的对应关系，还有端口是否都开了。如果相互之间<code>mongo &lt;主机名&gt;:&lt;端口&gt;</code>能连上，基本就没问题了。</p>
</blockquote>
<h1 id="Step-8-插入数据"><a class="header-anchor" href="#Step-8-插入数据"># </a>Step 8: 插入数据</h1>
<ul>
<li>用Ops Manager可以插入单条数据</li>
<li>用NoSQLBooster连接集群，用Import可以通过文件插入多条数据</li>
</ul>
<blockquote>
<p>连接NoSQLBooster时，需要在本机修改hosts文件。<br>
Windows的文件位置在<code>C:\Windows\System32\drivers\etc\hosts</code>，像Step 5一样添加内容（<strong>私网ip要改成公网ip</strong>）就好了。配置好了是可以通过<code>&lt;主机名&gt;:&lt;端口&gt;</code>连上的。<br>
<img src="/2019/09/Aliyun-MongoDBCluster/pic5.png" alt="pic5"></p>
</blockquote>
]]></content>
      <categories>
        <category>没有官方文档重要的教程</category>
      </categories>
      <tags>
        <tag>阿里云ECS</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>一份 Windows Terminal 配置笔记</title>
    <url>/2020/02/BeautifyWindowsTerminal/</url>
    <content><![CDATA[<!-- toc -->
<p><a href="https://github.com/microsoft/terminal" target="_blank" rel="noopener">Windows Terminal 的 github 传送门</a></p>
<h1 id="安装-Windows-Terminal"><a class="header-anchor" href="#安装-Windows-Terminal"># </a>安装 Windows Terminal</h1>
<p>到 <a href="https://www.microsoft.com/zh-cn/p/windows-terminal-preview/9n0dx20hk701?ocid=AID681541_aff_7593_1243925" target="_blank" rel="noopener">Microsoft Store</a> 就能安装啦！</p>
<h1 id="Profiles-json"><a class="header-anchor" href="#Profiles-json"># </a>Profiles.json</h1>
<p>Windows Terminal 的配置都在这里面，通过修改这里面的参数就能自定义自己的 Windows Terminal 啦！<br>
<a href="https://github.com/microsoft/terminal/blob/master/doc/cascadia/SettingsSchema.md" target="_blank" rel="noopener">Profiles.json 的参数说明</a><br>
先放一份我自己的效果图😝</p>
<p><img src="/2020/02/BeautifyWindowsTerminal/color.png" alt="color"></p>
<p>接下来就开始讲配置啦！</p>
<h2 id="背景"><a class="header-anchor" href="#背景"># </a>背景</h2>
<p>背景可以设置背景图片，但是我没有。我只是使用了<code>useAcrylic</code>和<code>acrylicOpacity</code>开启了毛玻璃效果而已。背景颜色在接下来要讲的<code>Schemes</code>中的<code>background</code>中设置。</p>
<h2 id="配色"><a class="header-anchor" href="#配色"># </a>配色</h2>
<p>通过 <a href="https://github.com/microsoft/terminal/blob/master/doc/cascadia/SettingsSchema.md#Schemes" target="_blank" rel="noopener"><code>Schemes</code></a> 设置自己喜欢的配色，然后在<code>name</code>中取上一个名字，就可以通过<code>colorScheme</code>调用啦！<br>
在<a href="https://github.com/mbadolato/iTerm2-Color-Schemes/tree/master/windowsterminal" target="_blank" rel="noopener">iTerm2</a>中已经有一些现成的配色方案了，直接使用就可以了。<br>
我使用的是修改后的<code>OneHalfLight</code>，将白色修改成了灰色，避免看不清的情况。同时还修改了光标的颜色<code>cursorColor</code>。</p>
<pre><code class="language-json">{
  &quot;profiles&quot;: [
    {
      &quot;colorScheme&quot;: &quot;OneHalfLight&quot;,
      &quot;cursorColor&quot;: &quot;#7A8181&quot;
    }
  ],
  &quot;schemes&quot;: [
    {
      &quot;name&quot;: &quot;OneHalfLight&quot;,
      &quot;black&quot;: &quot;#383a42&quot;,
      &quot;red&quot;: &quot;#e45649&quot;,
      &quot;green&quot;: &quot;#4876D6&quot;,
      &quot;yellow&quot;: &quot;#c18401&quot;,
      &quot;blue&quot;: &quot;#0184bc&quot;,
      &quot;purple&quot;: &quot;#a626a4&quot;,
      &quot;cyan&quot;: &quot;#0997b3&quot;,
      &quot;white&quot;: &quot;#7A8181&quot;,
      &quot;brightBlack&quot;: &quot;#4f525e&quot;,
      &quot;brightRed&quot;: &quot;#e06c75&quot;,
      &quot;brightGreen&quot;: &quot;#98c379&quot;,
      &quot;brightYellow&quot;: &quot;#e5c07b&quot;,
      &quot;brightBlue&quot;: &quot;#61afef&quot;,
      &quot;brightPurple&quot;: &quot;#c678dd&quot;,
      &quot;brightCyan&quot;: &quot;#56b6c2&quot;,
      &quot;brightWhite&quot;: &quot;#989FB1&quot;,
      &quot;background&quot;: &quot;#fafafa&quot;,
      &quot;foreground&quot;: &quot;#383a42&quot;
    }
  ]
}
</code></pre>
<h2 id="字体"><a class="header-anchor" href="#字体"># </a>字体</h2>
<p>字体可以通过<code>font-face</code>进行更改，但只能设置一个字体。如果想要同时拥有喜欢的英文等宽字体和中文等宽字体的话，可以使用<a href="https://github.com/nowar-fonts/Warcraft-Font-Merger" target="_blank" rel="noopener">WFM</a>进行合成。<br>
我使用的是<code>Consolas</code>和<code>Source Han Sans SC</code>（思源宋体）的混合字体。</p>
<h2 id="更多Tab"><a class="header-anchor" href="#更多Tab"># </a>更多Tab</h2>
<p>在<code>profiles</code>中，一个字典代表着一个选项窗口，可以通过设置<code>commandline</code>设置不同的命令得到不同便捷的选项窗口。<br>
我目前的选项窗口有这些👇</p>
<p><img src="/2020/02/BeautifyWindowsTerminal/tab.png" alt="tab"></p>
<p>以图中的iPython为例子，这是配置字典👇</p>
<pre><code class="language-json">{
      &quot;guid&quot;: &quot;{9434E8AE-D1E1-4F63-B8F7-F6F7DACD0C02}&quot;,
      &quot;hidden&quot;: false,
      &quot;name&quot;: &quot;IPython&quot;,
      &quot;commandline&quot;: &quot;ipython&quot;,
      &quot;acrylicOpacity&quot;: 0.75,
      &quot;useAcrylic&quot;: true,
      &quot;closeOnExit&quot;: true,
      &quot;fontFace&quot;: &quot;Consolas + Source Han Sans SC&quot;,
      &quot;colorScheme&quot;: &quot;OneHalfLight&quot;,
      &quot;tabTitle&quot;: &quot;IPython&quot;,
      &quot;icon&quot;: &quot;D:/Picture/Icon/python-144.png&quot;,
      &quot;cursorColor&quot;: &quot;#7A8181&quot;,
      &quot;cursorShape&quot;: &quot;bar&quot;,
      &quot;startingDirectory&quot;: null
}
</code></pre>
<p>能启动 iPython 的原因就是我在<code>commandline</code>中设置了<code>ipython</code>。如果你在<code>Powershell</code>中输入<code>ipython</code>可以启动 iPython 的话，那么这个窗口你就可以开启。<br>
每个选项窗口会有一个<code>guid</code>，这个可以随机生成，或者是通过<code>Visual Studio</code>中的工具 → 创建GUID 进行生成，你可以在全局中更改<code>defaultProfile</code>的 GUID 进行默认启动窗口的设置。<br>
我的 iPython 效果图👇</p>
<p><img src="/2020/02/BeautifyWindowsTerminal/ipython.png" alt="ipython"></p>
<h2 id="默认大小"><a class="header-anchor" href="#默认大小"># </a>默认大小</h2>
<p>在全局中（也就是<code>profiles</code>之前）设置<code>initialCols</code>和<code>initialRows</code>可以设置默认大小，我的设置为<code>90</code>和<code>30</code>。</p>
<h1 id="在当前文件夹中右键选择打开-Windows-Terminal"><a class="header-anchor" href="#在当前文件夹中右键选择打开-Windows-Terminal"># </a>在当前文件夹中右键选择打开 Windows Terminal</h1>
<p><code>cd</code>很麻烦，有的时候我们希望可以像<code>Git Bash Here</code>那样，在文件夹内右键就可以打开终端使用，这个通过修改注册表就可以完成。<br>
我们先将<code>Profiles.json</code>中的<code>startingDirectory</code>设置成<code>null</code>。<br>
然后创建一个<code>.reg</code>的文件，填写以下代码</p>
<pre><code class="language-powershell">Windows Registry Editor Version 5.00

[HKEY_CLASSES_ROOT\Directory\Background\shell\wt]
@=&quot;Windows Terminal Here&quot;
&quot;Icon&quot;=&quot;[YOUR ICON PATH]&quot;

[HKEY_CLASSES_ROOT\Directory\Background\shell\wt\command]
@=&quot;C:\\Users\\[YOURNAME]\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe&quot;
</code></pre>
<blockquote>
<p>Windows Terminal 的 Icon 可以在<a href="https://github.com/microsoft/terminal/blob/master/res/terminal.ico" target="_blank" rel="noopener">它的 github</a> 中找到</p>
</blockquote>
<p>然后运行。打开文件夹，按右键</p>
<p><img src="/2020/02/BeautifyWindowsTerminal/here.png" alt="here"></p>
<p>完成！</p>
]]></content>
      <categories>
        <category>搞点什么东东吧</category>
      </categories>
      <tags>
        <tag>Windows Terminal</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 使用 KaTeX 渲染数学公式</title>
    <url>/2019/07/HexoKatex/</url>
    <content><![CDATA[<h1 id="说点话"><a class="header-anchor" href="#说点话"># </a>_说点话</h1>
<p>保留了Hexo默认的Markdown渲染器<a href="https://github.com/hexojs/hexo-renderer-marked" target="_blank" rel="noopener">hexo-renderer-marked</a>，采用<a href="https://github.com/hexojs/hexo-math" target="_blank" rel="noopener">hexo-math</a>中的<a href="https://katex.org/" target="_blank" rel="noopener">KaTeX</a>引擎对数学公式进行渲染。</p>
<h1 id="食用方式"><a class="header-anchor" href="#食用方式"># </a>_食用方式</h1>
<h2 id="01-安装hexo-math"><a class="header-anchor" href="#01-安装hexo-math"># </a>01 安装hexo-math</h2>
<pre><code class="language-batch">npm install hexo-math --save
</code></pre>
<h2 id="02-配置hexo-math"><a class="header-anchor" href="#02-配置hexo-math"># </a>02 配置hexo-math</h2>
<p>打开根目录下的<code>_config.yml</code>，添加</p>
<pre><code class="language-yaml">plugin:
  - hexo-math
</code></pre>
<pre><code class="language-yaml">math:
  engine: 'katex'
  katex:
    css: https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css
    js: https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.js
    config:
      # KaTeX config
</code></pre>
<h2 id="03-重启Hexo"><a class="header-anchor" href="#03-重启Hexo"># </a>03 重启Hexo</h2>
<pre><code class="language-bash">hexo clean
hexo generate
hexo server
</code></pre>
<h2 id="04-更新-KaTeX"><a class="header-anchor" href="#04-更新-KaTeX"># </a>04 更新 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>KaTeX</mtext></mrow><annotation encoding="application/x-tex">\KaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89883em;vertical-align:-0.2155em;"></span><span class="mord text"><span class="mord textrm">K</span><span class="mspace" style="margin-right:-0.17em;"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.904999em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord text"><span class="mord textrm sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-0.15em;"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.46782999999999997em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span></span></h2>
<p><strong>本节在2020/03/01更新</strong>，因为有部分式子解析不成功，需要更新<br>
进入<code>YOUR_BLOG_PATH\node_modules\hexo-math</code>文件夹，点击<code>package.json</code>可以看到</p>
<pre><code class="language-json">&quot;dependencies&quot;: {
    &quot;html-entities&quot;: &quot;^1.1.3&quot;,
    &quot;katex&quot;: &quot;^0.6.0&quot;
  },
</code></pre>
<p>表明它依赖的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>KaTeX</mtext></mrow><annotation encoding="application/x-tex">\KaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89883em;vertical-align:-0.2155em;"></span><span class="mord text"><span class="mord textrm">K</span><span class="mspace" style="margin-right:-0.17em;"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.904999em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord text"><span class="mord textrm sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-0.15em;"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.46782999999999997em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span></span>版本为<code>0.6.0</code>，而目前最新的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>KaTeX</mtext></mrow><annotation encoding="application/x-tex">\KaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89883em;vertical-align:-0.2155em;"></span><span class="mord text"><span class="mord textrm">K</span><span class="mspace" style="margin-right:-0.17em;"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.904999em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord text"><span class="mord textrm sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-0.15em;"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.46782999999999997em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span></span>版本为<code>0.11.1</code>，所以我们将<code>0.6.0</code>改为<code>0.11.1</code><br>
同时需要在根目录下的<code>_config.yml</code>中把<code>css</code>和<code>js</code>中的版本改成最新的</p>
<pre><code class="language-json">&quot;dependencies&quot;: {
    &quot;html-entities&quot;: &quot;^1.1.3&quot;,
    &quot;katex&quot;: &quot;^0.11.1&quot;
  },
</code></pre>
<pre><code class="language-yaml">math:
  engine: 'katex'
  katex:
    css: https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css
    js: https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.js
    config:
      # KaTeX config
</code></pre>
<h1 id="注意事项"><a class="header-anchor" href="#注意事项"># </a>_注意事项</h1>
<ul>
<li>css和js的cdn必须自定义，默认不可用</li>
<li><code>$...$</code> 和 <code>$$...$$</code> 需要被替换成 <code>math</code> 块</li>
<li>hexo-math也可以采用MathJax引擎，但速度慢且没有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>KaTeX</mtext></mrow><annotation encoding="application/x-tex">\KaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89883em;vertical-align:-0.2155em;"></span><span class="mord text"><span class="mord textrm">K</span><span class="mspace" style="margin-right:-0.17em;"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.904999em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord text"><span class="mord textrm sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-0.15em;"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.46782999999999997em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span></span>好看</li>
<li>最好参考官方文档食用</li>
</ul>
<h1 id="附录"><a class="header-anchor" href="#附录"># </a>_附录</h1>
<p><a href="https://katex.org/docs/supported.html" target="_blank" rel="noopener">KaTeX的食用文档</a></p>
]]></content>
      <categories>
        <category>建站相关</category>
      </categories>
      <tags>
        <tag>KaTeX</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Windows 10 上安装 CUDA 10.0</title>
    <url>/2020/03/InstallCUDA10/</url>
    <content><![CDATA[<p>因为有<a href="https://docs.nvidia.com/cuda/archive/10.0/cuda-installation-guide-microsoft-windows/index.html" target="_blank" rel="noopener">官方文档</a>了，所以就记录一点和文档不一样的地方</p>
<h1 id="验证安装"><a class="header-anchor" href="#验证安装"># </a>验证安装</h1>
<p><code>deviceQuery.exe</code>和<code>bandwidthTest.exe</code>的地址我的是在<code>NVIDIA GPU Computing Toolkit\CUDA\v10.0\extras\demo_suite</code></p>
<h1 id="在-Visual-Studio-2019-中运行-CUDA-项目"><a class="header-anchor" href="#在-Visual-Studio-2019-中运行-CUDA-项目"># </a>在 Visual Studio 2019 中运行 CUDA 项目</h1>
<p>因为时间的原因，在 CUDA 10.0 发布的时候并没有 Visual Studio 2019 这个东西，所以它给的示例工程只到了 Visual Studio 2017 版本，直接运行会报错，提示找不到<code>CUDA 10.0.props</code>这个文件<br>
经过一阵查找，我找到了它在<code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.0\extras\visual_studio_integration\MSBuildExtensions</code>，尽管我的<code>CUDA</code>安装在了D盘<br>
这时候我们只需要将<code>CUDA 10.0.props</code>以及和它在一个文件夹里的文件复制到报错的那个文件夹里就行了<br>
现在可以打开解决方案了，会提示<code>若要使用 Visual Studio 2019 (v142) 生成工具进行生成，请单击&quot;项目&quot;菜单或右键单击解决方案，然后选择&quot;重定向解决方案...&quot;。安装 Visual Studio 2017 (v141) 可使用 Visual Studio 2017 (v141) 生成工具进行生成。</code><br>
如果我们使用 Visual Studio 2019 (v142) 进行生成，会报错<code>#error:  -- unsupported Microsoft Visual Studio version! Only the versions between 2013 and 2017 (inclusive) are supported!</code>，所以我们应该安装 Visual Studio 2017 (v141)，然后在属性集中把<strong>平台工具集</strong>修改为 Visual Studio 2017 (v141)</p>
<h1 id="OpenGL-的安装"><a class="header-anchor" href="#OpenGL-的安装"># </a>OpenGL 的安装</h1>
<p>在翻 CUDA 的文件夹的时候发现了 freeglut 和 glew，那就顺便安装一下 OpenGL 好了。我的 C++ IDE 是 JetBrains 的 CLion，采用 MinGW-w64 环境<br>
首先先找到 freeglut 和 glew 的 <code>.h</code> <code>.lib</code> <code>.dll</code> 的位置<br>
我的<code>.h</code>文件在<code>NVIDIA GPU Computing Toolkit/CUDA Samples/v10.0/common/inc/GL</code>，<code>.lib</code>文件在<code>NVIDIA GPU Computing Toolkit\CUDA Samples\v10.0\common\lib\x64</code>，<code>.dll</code>在<code>NVIDIA GPU Computing Toolkit\CUDA Samples\v10.0\bin\win64\Release</code>和<code>NVIDIA GPU Computing Toolkit\CUDA\v10.0\extras\demo_suite</code>下都有，但它们大小是一样的，随便选择就行了<br>
把<code>.dll</code>移动到<code>C:\Windows\System32</code>和<code>C:\Windows\SysWOW64</code>下<br>
因为<code>NVIDIA GPU Computing Toolkit</code>路径中含有空格，在 CMakeLists.txt 中<code>link_directories</code>和<code>include_directories</code>引入时需要将空格转义<code>\ </code></p>
<pre><code class="language-cmake">link_directories(D:/Program/NVIDIA\ GPU\ Computing\ Toolkit/CUDA\ Samples/v10.0/common/lib/x64)
include_directories(D:/Program/NVIDIA\ GPU\ Computing\ Toolkit/CUDA/v10.0/extras/CUPTI/include)
include_directories(D:/Program/NVIDIA\ GPU\ Computing\ Toolkit/CUDA\ Samples/v10.0/common/inc)
</code></pre>
<p>然后添加需要编译的 cpp，并和<code>.lib</code>链接起来</p>
<pre><code class="language-cmake">add_executable(YOUR_PROJECT_NAME main.cpp)
target_link_libraries(YOUR_PROJECT_NAME -lopengl32 -lglu32 freeglut.lib glew64.lib)
</code></pre>
<blockquote>
<p>这里的<code>opengl32</code>和<code>glu32</code>是必要的，不然会报错</p>
</blockquote>
<p>运行后，我的程序出现了报错，<code>#include&lt;GL/gl.h&gt;</code>出错了，因为有<code>freeglut.h</code>的文件夹中并没有<code>gl.h</code>和<code>glu.h</code>，我在<code>NVIDIA GPU Computing Toolkit\CUDA\v10.0\extras\CUPTI\include\GL</code>中找到了这两个文件，将他们移动到了<code>D:\Tool\mingw64\include\GL</code>中，再次运行就没有报错了<br>
附上一个测试程序，这个是我上计算机图形学时配 OpenGL 自动生成的示例程序</p>
<pre><code class="language-cpp">/*
 * GLUT Shapes Demo
 *
 * Written by Nigel Stewart November 2003
 *
 * This program is test harness for the sphere, cone
 * and torus shapes in GLUT.
 *
 * Spinning wireframe and smooth shaded shapes are
 * displayed until the ESC or q key is pressed.  The
 * number of geometry stacks and slices can be adjusted
 * using the + and - keys.
 */

/* 这里使用freeglut.h，而不是glut.h */
#include &lt;GL/freeglut.h&gt;

#include &lt;stdlib.h&gt;

static int slices = 16;
static int stacks = 16;

/* GLUT callback Handlers */

static void resize(int width, int height)
{
    const float ar = (float) width / (float) height;

    glViewport(0, 0, width, height);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glFrustum(-ar, ar, -1.0, 1.0, 2.0, 100.0);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity() ;
}

static void display(void)
{
    const double t = glutGet(GLUT_ELAPSED_TIME) / 1000.0;
    const double a = t*90.0;

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glColor3d(1,0,0);

    glPushMatrix();
        glTranslated(-2.4,1.2,-6);
        glRotated(60,1,0,0);
        glRotated(a,0,0,1);
        glutSolidSphere(1,slices,stacks);
    glPopMatrix();

    glPushMatrix();
        glTranslated(0,1.2,-6);
        glRotated(60,1,0,0);
        glRotated(a,0,0,1);
        glutSolidCone(1,1,slices,stacks);
    glPopMatrix();

    glPushMatrix();
        glTranslated(2.4,1.2,-6);
        glRotated(60,1,0,0);
        glRotated(a,0,0,1);
        glutSolidTorus(0.2,0.8,slices,stacks);
    glPopMatrix();

    glPushMatrix();
        glTranslated(-2.4,-1.2,-6);
        glRotated(60,1,0,0);
        glRotated(a,0,0,1);
        glutWireSphere(1,slices,stacks);
    glPopMatrix();

    glPushMatrix();
        glTranslated(0,-1.2,-6);
        glRotated(60,1,0,0);
        glRotated(a,0,0,1);
        glutWireCone(1,1,slices,stacks);
    glPopMatrix();

    glPushMatrix();
        glTranslated(2.4,-1.2,-6);
        glRotated(60,1,0,0);
        glRotated(a,0,0,1);
        glutWireTorus(0.2,0.8,slices,stacks);
    glPopMatrix();

    glutSwapBuffers();
}


static void key(unsigned char key, int x, int y)
{
    switch (key)
    {
        case 27 :
        case 'q':
            exit(0);
            break;

        case '+':
            slices++;
            stacks++;
            break;

        case '-':
            if (slices&gt;3 &amp;&amp; stacks&gt;3)
            {
                slices--;
                stacks--;
            }
            break;
    }

    glutPostRedisplay();
}

static void idle(void)
{
    glutPostRedisplay();
}

const GLfloat light_ambient[]  = { 0.0f, 0.0f, 0.0f, 1.0f };
const GLfloat light_diffuse[]  = { 1.0f, 1.0f, 1.0f, 1.0f };
const GLfloat light_specular[] = { 1.0f, 1.0f, 1.0f, 1.0f };
const GLfloat light_position[] = { 2.0f, 5.0f, 5.0f, 0.0f };

const GLfloat mat_ambient[]    = { 0.7f, 0.7f, 0.7f, 1.0f };
const GLfloat mat_diffuse[]    = { 0.8f, 0.8f, 0.8f, 1.0f };
const GLfloat mat_specular[]   = { 1.0f, 1.0f, 1.0f, 1.0f };
const GLfloat high_shininess[] = { 100.0f };

/* Program entry point */

int main(int argc, char *argv[])
{
    glutInit(&amp;argc, argv);
    glutInitWindowSize(640,480);
    glutInitWindowPosition(10,10);
    glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH);

    glutCreateWindow(&quot;GLUT Shapes&quot;);

    glutReshapeFunc(resize);
    glutDisplayFunc(display);
    glutKeyboardFunc(key);
    glutIdleFunc(idle);

    glClearColor(1,1,1,1);
    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);

    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);

    glEnable(GL_LIGHT0);
    glEnable(GL_NORMALIZE);
    glEnable(GL_COLOR_MATERIAL);
    glEnable(GL_LIGHTING);

    glLightfv(GL_LIGHT0, GL_AMBIENT,  light_ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE,  light_diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);
    glLightfv(GL_LIGHT0, GL_POSITION, light_position);

    glMaterialfv(GL_FRONT, GL_AMBIENT,   mat_ambient);
    glMaterialfv(GL_FRONT, GL_DIFFUSE,   mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR,  mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, high_shininess);

    glutMainLoop();

    return EXIT_SUCCESS;
}
</code></pre>
]]></content>
      <categories>
        <category>没有官方文档重要的教程</category>
      </categories>
      <tags>
        <tag>CUDA 10.0</tag>
        <tag>nVidia</tag>
        <tag>Windows 10</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>「LeetCode」多线程</title>
    <url>/2020/03/LeetcodeMultithreading/</url>
    <content><![CDATA[<p><em>不含经典会员才能做的题</em></p>
<h1 id="1114-按序打印"><a class="header-anchor" href="#1114-按序打印"># </a>1114 按序打印</h1>
<p><a href="https://leetcode-cn.com/problems/print-in-order/" target="_blank" rel="noopener">传送门</a></p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">执行用时</th>
<th style="text-align:center">内存消耗</th>
<th style="text-align:center">提交时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>packaged_task</code></td>
<td style="text-align:center">56 ms</td>
<td style="text-align:center">7.2 MB</td>
<td style="text-align:center">2022/03/22 22:49</td>
</tr>
<tr>
<td style="text-align:center"><code>future promise</code></td>
<td style="text-align:center">76 ms</td>
<td style="text-align:center">7.2 MB</td>
<td style="text-align:center">2022/03/22 22:31</td>
</tr>
<tr>
<td style="text-align:center"><code>condition_variable</code></td>
<td style="text-align:center">84 ms</td>
<td style="text-align:center">6.9 MB</td>
<td style="text-align:center">2022/03/22 22:14</td>
</tr>
<tr>
<td style="text-align:center"><code>semaphore.h (Linux)</code></td>
<td style="text-align:center">144 ms</td>
<td style="text-align:center">8.2 MB</td>
<td style="text-align:center">2020/03/20 13:57</td>
</tr>
<tr>
<td style="text-align:center"><code>semaphore (C++20)</code></td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center"><code>mutex</code></td>
<td style="text-align:center">124 ms</td>
<td style="text-align:center">8.3 MB</td>
<td style="text-align:center">2020/03/20 23:24</td>
</tr>
<tr>
<td style="text-align:center"><code>lock_guard&lt;mutex&gt;</code></td>
<td style="text-align:center">160 ms</td>
<td style="text-align:center">8.2 MB</td>
<td style="text-align:center">2020/03/20 23:32</td>
</tr>
<tr>
<td style="text-align:center"><code>atomic_flag</code></td>
<td style="text-align:center">1516 ms</td>
<td style="text-align:center">7.1 MB</td>
<td style="text-align:center">2023/03/23 00:05</td>
</tr>
</tbody>
</table>
<h2 id="任务-C-11"><a class="header-anchor" href="#任务-C-11"># </a>任务 (C++ 11)</h2>
<h3 id="packaged-task"><a class="header-anchor" href="#packaged-task"># </a>packaged_task</h3>
<pre><code class="language-cpp">class Foo {
    using TASK_TYPE = void();
    function&lt;TASK_TYPE&gt; task = [](){};
    packaged_task&lt;TASK_TYPE&gt; pt1{task}, pt2{task};
public:
    Foo() {
        
    }

    void first(function&lt;void()&gt; printFirst) {
        
        // printFirst() outputs &quot;first&quot;. Do not change or remove this line.
        printFirst();
        pt1();
    }

    void second(function&lt;void()&gt; printSecond) {
        future&lt;void&gt; f{pt1.get_future()};
        f.get();
        // printSecond() outputs &quot;second&quot;. Do not change or remove this line.
        printSecond();
        pt2();
    }

    void third(function&lt;void()&gt; printThird) {
        future&lt;void&gt; f{pt2.get_future()};
        f.get();
        // printThird() outputs &quot;third&quot;. Do not change or remove this line.
        printThird();
    }
};
</code></pre>
<h3 id="future-和-promise"><a class="header-anchor" href="#future-和-promise"># </a>future 和 promise</h3>
<pre><code class="language-cpp">class Foo {
    promise&lt;bool&gt; p1, p2;
public:
    Foo() {
        
    }

    void first(function&lt;void()&gt; printFirst) {
        
        // printFirst() outputs &quot;first&quot;. Do not change or remove this line.
        printFirst();
        p1.set_value(true);
    }

    void second(function&lt;void()&gt; printSecond) {
        future&lt;bool&gt; f{p1.get_future()};
        f.wait();
        // printSecond() outputs &quot;second&quot;. Do not change or remove this line.
        printSecond();
        p2.set_value(true);
    }

    void third(function&lt;void()&gt; printThird) {
        future&lt;bool&gt; f{p2.get_future()};
        f.wait();
        // printThird() outputs &quot;third&quot;. Do not change or remove this line.
        printThird();
    }
};
</code></pre>
<h2 id="条件变量-C-11"><a class="header-anchor" href="#条件变量-C-11"># </a>条件变量 (C++ 11)</h2>
<pre><code class="language-cpp">class Foo {
    mutex m1, m2;
    condition_variable cv1, cv2;
    int cur;
public:
    Foo() {
        cur = 0;
    }

    void first(function&lt;void()&gt; printFirst) {
        
        // printFirst() outputs &quot;first&quot;. Do not change or remove this line.
        printFirst();
        cur = 1;
        cv1.notify_one();
    }

    void second(function&lt;void()&gt; printSecond) {
        unique_lock&lt;mutex&gt; lock{m1};
        cv1.wait(lock, [this](){return cur == 1;});
        // printSecond() outputs &quot;second&quot;. Do not change or remove this line.
        printSecond();
        lock.unlock();
        cur = 2;
        cv2.notify_one();
    }

    void third(function&lt;void()&gt; printThird) {
        unique_lock&lt;mutex&gt; lock{m2};
        cv2.wait(lock, [this](){return cur == 2;});
        // printThird() outputs &quot;third&quot;. Do not change or remove this line.
        printThird();
        lock.unlock();
        cur = 3;
    }
};
</code></pre>
<h2 id="信号量"><a class="header-anchor" href="#信号量"># </a>信号量</h2>
<h3 id="semaphore-h-Linux"><a class="header-anchor" href="#semaphore-h-Linux"># </a>semaphore.h (Linux)</h3>
<pre><code class="language-cpp">#include &lt;semaphore.h&gt;
class Foo {
private:
    sem_t s1,s2;

public:
    Foo() {
        sem_init(&amp;s1,0,0);
        sem_init(&amp;s2,0,0);
    }

    void first(function&lt;void()&gt; printFirst) { 
        // printFirst() outputs &quot;first&quot;. Do not change or remove this line.
        printFirst();
        sem_post(&amp;s1);
    }

    void second(function&lt;void()&gt; printSecond) {
        sem_wait(&amp;s1);
        // printSecond() outputs &quot;second&quot;. Do not change or remove this line.
        printSecond();
        sem_post(&amp;s2);
    }

    void third(function&lt;void()&gt; printThird) {
        sem_wait(&amp;s2);
        // printThird() outputs &quot;third&quot;. Do not change or remove this line.
        printThird();
    }
};
</code></pre>
<h3 id="semaphore-C-20-LeetCode-不支持"><a class="header-anchor" href="#semaphore-C-20-LeetCode-不支持"># </a>semaphore (C++ 20) LeetCode 不支持</h3>
<pre><code class="language-cpp">#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;semaphore&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

using namespace std;

class Foo {
    binary_semaphore s1{0}, s2{0};

   public:
    Foo() {}

    void first(function&lt;void()&gt; printFirst) {
        // printFirst() outputs &quot;first&quot;. Do not change or remove this line.
        printFirst();
        s1.release();
    }

    void second(function&lt;void()&gt; printSecond) {
        s1.acquire();
        // printSecond() outputs &quot;second&quot;. Do not change or remove this line.
        printSecond();
        s2.release();
    }

    void third(function&lt;void()&gt; printThird) {
        s2.acquire();
        // printThird() outputs &quot;third&quot;. Do not change or remove this line.
        printThird();
    }
};

int main() {
    vector&lt;int&gt; order{3, 2, 1};
    vector&lt;thread&gt; pool;
    Foo foo = Foo();
    for (int i : order) {
        if (i == 1)
            pool.emplace_back(&amp;Foo::first, &amp;foo, []() {
                cout &lt;&lt; &quot;first&quot;;
            });  // 与成员函数绑定需要用
                 // &amp;类名::成员函数名，再传递对象，再传递参数
        else if (i == 2)
            pool.emplace_back(&amp;Foo::second, &amp;foo, []() { cout &lt;&lt; &quot;second&quot;; });
        else if (i == 3)
            pool.emplace_back(&amp;Foo::third, &amp;foo, []() { cout &lt;&lt; &quot;third&quot;; });
    }
    for (thread &amp;t : pool) {
        t.join();
    }
}
</code></pre>
<h2 id="互斥信号量-C-11"><a class="header-anchor" href="#互斥信号量-C-11"># </a>互斥信号量 (C++ 11)</h2>
<h3 id="mutex"><a class="header-anchor" href="#mutex"># </a>mutex</h3>
<pre><code class="language-cpp">class Foo {
private:
    mutex m1, m2;

public:
    Foo() {
        m1.lock();
        m2.lock();
    }

    void first(function&lt;void()&gt; printFirst) {
        // printFirst() outputs &quot;first&quot;. Do not change or remove this line.
        printFirst();
        m1.unlock();
    }

    void second(function&lt;void()&gt; printSecond) {
        m1.lock();
        // printSecond() outputs &quot;second&quot;. Do not change or remove this line.
        printSecond();
        m2.unlock();
    }

    void third(function&lt;void()&gt; printThird) {
        m2.lock();
        // printThird() outputs &quot;third&quot;. Do not change or remove this line.
        printThird();
    }
};
</code></pre>
<h3 id="lock-guard-mutex"><a class="header-anchor" href="#lock-guard-mutex"># </a>lock_guard&lt;mutex&gt;</h3>
<pre><code class="language-cpp">#include &lt;mutex&gt;
class Foo {
private:
    mutex m1, m2;

public:
    Foo() {
        m1.lock();
        m2.lock();
    }

    void first(function&lt;void()&gt; printFirst) {
        // printFirst() outputs &quot;first&quot;. Do not change or remove this line.
        printFirst();
        m1.unlock();
    }

    void second(function&lt;void()&gt; printSecond) {
        lock_guard&lt;mutex&gt; lk(m1);
        // printSecond() outputs &quot;second&quot;. Do not change or remove this line.
        printSecond();
        m2.unlock();
    }

    void third(function&lt;void()&gt; printThird) {
        lock_guard&lt;mutex&gt; lk(m2);
        // printThird() outputs &quot;third&quot;. Do not change or remove this line.
        printThird();
    }
};
</code></pre>
<h2 id="原子-C-11"><a class="header-anchor" href="#原子-C-11"># </a>原子 (C++ 11)</h2>
<h3 id="atomic-flag"><a class="header-anchor" href="#atomic-flag"># </a>atomic_flag</h3>
<pre><code class="language-cpp">class Foo {
    atomic_flag f1, f2;
public:
    Foo() {
        f1.test_and_set(memory_order_acquire);
        f2.test_and_set(memory_order_acquire);
    }

    void first(function&lt;void()&gt; printFirst) {
        
        // printFirst() outputs &quot;first&quot;. Do not change or remove this line.
        printFirst();
        f1.clear(memory_order_release);
    }

    void second(function&lt;void()&gt; printSecond) {
        while (f1.test_and_set(memory_order_acquire));
        // printSecond() outputs &quot;second&quot;. Do not change or remove this line.
        printSecond();
        f2.clear(memory_order_release);
    }

    void third(function&lt;void()&gt; printThird) {
        while (f2.test_and_set(memory_order_acquire));
        // printThird() outputs &quot;third&quot;. Do not change or remove this line.
        printThird();
    }
};
</code></pre>
<h1 id="1115-Bar"><a class="header-anchor" href="#1115-Bar"># </a>1115 Bar</h1>
<p><a href="https://leetcode-cn.com/problems/print-foobar-alternately/" target="_blank" rel="noopener">传送门</a></p>
<pre><code class="language-cpp">class FooBar {
private:
    int n;
    mutex m1,m2;

public:
    FooBar(int n) {
        this-&gt;n = n;
        m1.lock();
        m2.unlock();
    }

    void foo(function&lt;void()&gt; printFoo) {
        for (int i = 0; i &lt; n; i++) {
            m2.lock();
            // printFoo() outputs &quot;foo&quot;. Do not change or remove this line.
            printFoo();
            m1.unlock();
        }
    }

    void bar(function&lt;void()&gt; printBar) {
        for (int i = 0; i &lt; n; i++) {
            m1.lock();
            // printBar() outputs &quot;bar&quot;. Do not change or remove this line.
            printBar();
            m2.unlock();
        }
    }
};
</code></pre>
<h1 id="1116-打印零与奇偶数"><a class="header-anchor" href="#1116-打印零与奇偶数"># </a>1116 打印零与奇偶数</h1>
<p><a href="https://leetcode-cn.com/problems/print-zero-even-odd/" target="_blank" rel="noopener">传送门</a></p>
<pre><code class="language-cpp">class ZeroEvenOdd {
private:
    int n;
    mutex z,e,o;

public:
    ZeroEvenOdd(int n) {
        this-&gt;n = n;
        z.unlock();
        e.lock();
        o.lock();
    }

    // printNumber(x) outputs &quot;x&quot;, where x is an integer.
    void zero(function&lt;void(int)&gt; printNumber) {
        for(int i=1;i&lt;=n;i++){
            z.lock();
            printNumber(0);
            if(i%2)o.unlock();
            else e.unlock();
        }
    }

    void even(function&lt;void(int)&gt; printNumber) {
        for(int i=2;i&lt;=n;i+=2){
            e.lock();
            printNumber(i);
            z.unlock();
        }
    }

    void odd(function&lt;void(int)&gt; printNumber) {
        for(int i=1;i&lt;=n;i+=2){
            o.lock();
            printNumber(i);
            z.unlock();
        }
    }
};
</code></pre>
<h1 id="1117-H2O-生成"><a class="header-anchor" href="#1117-H2O-生成"># </a>1117 H2O 生成</h1>
<p><a href="https://leetcode-cn.com/problems/building-h2o/" target="_blank" rel="noopener">传送门</a></p>
<pre><code class="language-cpp">#include &lt;semaphore.h&gt;
class H2O {
private:
    sem_t h,o;
    int cnt;

public:
    H2O() {
        sem_init(&amp;h, 0, 2);
        sem_init(&amp;o, 0, 1);
        cnt=0;
    }

    void hydrogen(function&lt;void()&gt; releaseHydrogen) {
        sem_wait(&amp;h);
        // releaseHydrogen() outputs &quot;H&quot;. Do not change or remove this line.
        releaseHydrogen();
        cnt++;
        if(cnt==2){
            sem_post(&amp;o);
            cnt=0;
        }
    }

    void oxygen(function&lt;void()&gt; releaseOxygen) {
        sem_wait(&amp;o);
        // releaseOxygen() outputs &quot;O&quot;. Do not change or remove this line.
        releaseOxygen();
        sem_post(&amp;h);
        sem_post(&amp;h);
    }
};
</code></pre>
<h1 id="1195-交替打印字符串"><a class="header-anchor" href="#1195-交替打印字符串"># </a>1195 交替打印字符串</h1>
<p><a href="https://leetcode-cn.com/problems/fizz-buzz-multithreaded/" target="_blank" rel="noopener">传送门</a></p>
<pre><code class="language-cpp">class FizzBuzz {
private:
    int n;
    mutex f,b,fb,num;

public:
    FizzBuzz(int n) {
        this-&gt;n = n;
        f.lock();
        b.lock();
        fb.lock();
    }

    // printFizz() outputs &quot;fizz&quot;.
    void fizz(function&lt;void()&gt; printFizz) {
        for(int i=3;i&lt;=n;i+=3){
            if(i%5==0)continue;
            f.lock();
            printFizz();
            num.unlock();
        }
    }

    // printBuzz() outputs &quot;buzz&quot;.
    void buzz(function&lt;void()&gt; printBuzz) {
        for(int i=5;i&lt;=n;i+=5){
            if(i%3==0)continue;
            b.lock();
            printBuzz();
            num.unlock();
        }
    }

    // printFizzBuzz() outputs &quot;fizzbuzz&quot;.
    void fizzbuzz(function&lt;void()&gt; printFizzBuzz) {
        for(int i=15;i&lt;=n;i+=15){
            fb.lock();
            printFizzBuzz();
            num.unlock();
        }
    }

    // printNumber(x) outputs &quot;x&quot;, where x is an integer.
    void number(function&lt;void(int)&gt; printNumber) {
        for(int i=1;i&lt;=n;i++){
            num.lock();
            if(i%3==0&amp;&amp;i%5==0)fb.unlock();
            else if(i%3==0)f.unlock();
            else if(i%5==0)b.unlock();
            else {
                printNumber(i);
                num.unlock();
            }
        }
    }
};
</code></pre>
<h1 id="1226-哲学家进餐"><a class="header-anchor" href="#1226-哲学家进餐"># </a>1226 哲学家进餐</h1>
<p><a href="https://leetcode-cn.com/problems/the-dining-philosophers/" target="_blank" rel="noopener">传送门</a><br>
操作系统书上的例子<br>
用一个信号量表示一只叉子，由这五个信号量构成信号量数组</p>
<pre><code class="language-cpp">class DiningPhilosophers {
private:
    mutex fork[5];
public:
    DiningPhilosophers() {
        
    }

    void wantsToEat(int philosopher,
                    function&lt;void()&gt; pickLeftFork,
                    function&lt;void()&gt; pickRightFork,
                    function&lt;void()&gt; eat,
                    function&lt;void()&gt; putLeftFork,
                    function&lt;void()&gt; putRightFork) {
        fork[philosopher].lock();
        pickLeftFork();
        fork[(philosopher+1)%5].lock();
        pickRightFork();
        eat();
        putLeftFork();
        fork[philosopher].unlock();
        putRightFork();
        fork[(philosopher+1)%5].unlock();
    }
};
</code></pre>
<p>虽然通过提交了，但是存在缺陷，可能会造成<strong>死锁</strong>。假如五位哲学家同时饥饿而各自拿起左边的叉子时，就会使五个互斥信号量均被锁住，当他们再试图去拿右边的叉子时，都将因无叉子可拿而无限期地等待。<br>
总共有<strong>三种</strong>解决方法：</p>
<h2 id="最多可允许四位哲学家同时进餐"><a class="header-anchor" href="#最多可允许四位哲学家同时进餐"># </a>最多可允许四位哲学家同时进餐</h2>
<p>至多只允许有四位哲学家同时去拿左边的叉子，最终能保证至少有一位哲学家能够进餐，并在用毕时能释放出他用过的两只叉子，从而使更多的哲学家能够进餐。</p>
<pre><code class="language-cpp">#include &lt;semaphore.h&gt;
class DiningPhilosophers {
private:
    sem_t s,fork[5];
public:
    DiningPhilosophers() {
        // 最多只允许4位同时进餐
        sem_init(&amp;s,0,4);
        // 叉子的信号量
        for(int i=0;i&lt;5;i++){
            sem_init(&amp;fork[i],0,1);
        }
    }

    void wantsToEat(int philosopher,
                    function&lt;void()&gt; pickLeftFork,
                    function&lt;void()&gt; pickRightFork,
                    function&lt;void()&gt; eat,
                    function&lt;void()&gt; putLeftFork,
                    function&lt;void()&gt; putRightFork) {
        int l=philosopher,r=(philosopher+1)%5;
        sem_wait(&amp;s);
        sem_wait(&amp;fork[l]);
        pickLeftFork();
        sem_wait(&amp;fork[r]);
        pickRightFork();
        eat();
        putLeftFork();
        sem_post(&amp;fork[l]);
        putRightFork();
        sem_post(&amp;fork[r]);
        sem_post(&amp;s);
    }
};
</code></pre>
<blockquote>
<p>执行用时：224 ms<br>
内存消耗：13.2 MB</p>
</blockquote>
<h2 id="同时拿左右两只叉子"><a class="header-anchor" href="#同时拿左右两只叉子"># </a>同时拿左右两只叉子</h2>
<p>仅当哲学家的左、右两只叉子均可用时，才允许他拿起叉子进餐。需要使用信号量集（AND型信号量）。<br>
说实话我不知道这个AND型信号量要怎么同时拿叉子，书上写的Sswait也是一个for循环按顺序控制，如果同时处理Sswait的话感觉还是解决不了五人同时相吃饭的问题（因为左右两个叉子的信号量都是1，同时拿的操作其实还是按顺序的，先拿左再拿右，如果五个人左边都拿了，那么右边就都死锁了）。<br>
所以我多设置了一个信号量，当两只叉子都被拿起的时候，只能允许最多<strong>两个人</strong>同时进餐。</p>
<pre><code class="language-cpp">#include &lt;semaphore.h&gt;
class DiningPhilosophers {
private:
    sem_t fork[5],s;
public:
    DiningPhilosophers() {
        // 如果同时拿起两只叉子的话，可以同时有两个人进餐
        sem_init(&amp;s,0,2);
        // 当且仅当两只叉子均可用的时候，可以进餐
        sem_init(&amp;s,0,1);
        for(int i=0;i&lt;5;i++){
            sem_init(&amp;fork[i],0,1);
        }
    }
    
    // AND 型信号量
    void Sswait(sem_t left,sem_t right){
        int lval,rval;
        sem_getvalue(&amp;left,&amp;lval);
        sem_getvalue(&amp;right,&amp;rval);
        if(lval==1&amp;&amp;rval==1){
            sem_wait(&amp;s);
            sem_wait(&amp;left);
            sem_wait(&amp;right);
        }
    }

    void wantsToEat(int philosopher,
                    function&lt;void()&gt; pickLeftFork,
                    function&lt;void()&gt; pickRightFork,
                    function&lt;void()&gt; eat,
                    function&lt;void()&gt; putLeftFork,
                    function&lt;void()&gt; putRightFork) {
        int l=philosopher,r=(philosopher+1)%5;
        Sswait(fork[l],fork[r]);
        pickLeftFork();
        pickRightFork();
        eat();
        putLeftFork();
        sem_post(&amp;fork[l]);
        putRightFork();
        sem_post(&amp;fork[r]);
        sem_post(&amp;s);
    }
};
</code></pre>
<blockquote>
<p>执行用时：204 ms<br>
内存消耗：13.4 MB</p>
</blockquote>
<h2 id="先拿奇数号叉子，再拿偶数号叉子"><a class="header-anchor" href="#先拿奇数号叉子，再拿偶数号叉子"># </a>先拿奇数号叉子，再拿偶数号叉子</h2>
<p>规定奇数号哲学家先拿他左边的叉子，然后再去拿右边的叉子，而偶数号哲学家则相反。即五位哲学家都先竞争奇数号叉子，获得后，再去竞争偶数号叉子，最后总会有一位哲学家能获得两只叉子而进餐。</p>
<pre><code class="language-cpp">class DiningPhilosophers {
private:
    mutex fork[5];
public:
    DiningPhilosophers() {

    }

    void wantsToEat(int philosopher,
                    function&lt;void()&gt; pickLeftFork,
                    function&lt;void()&gt; pickRightFork,
                    function&lt;void()&gt; eat,
                    function&lt;void()&gt; putLeftFork,
                    function&lt;void()&gt; putRightFork) {
        int l=philosopher,r=(philosopher+1)%5;
        if(philosopher%2){
            fork[l].lock();
            pickLeftFork();
            fork[r].lock();
            pickRightFork();
        }else{
            fork[r].lock();
            pickRightFork();
            fork[l].lock();
            pickLeftFork();
        }
        eat();
        putLeftFork();
        fork[l].unlock();
        putRightFork();
        fork[r].unlock();
    }
};
</code></pre>
<blockquote>
<p>执行用时：212 ms<br>
内存消耗：13.6 MB</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>「学习笔记」RSA中的数论</title>
    <url>/2022/10/RSA/</url>
    <content><![CDATA[<h1 id="费马小定理"><a class="header-anchor" href="#费马小定理"># </a>费马小定理</h1>
<p>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 是素数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 是正整数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(a, p)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>≡</mo><mn>1</mn><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">a ^ {p - 1} \equiv 1 \mod p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span></span></span></span>。<br>
另一种形式：若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 是素数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 是正整数，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mi>p</mi></msup><mo>≡</mo><mi>a</mi><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">a ^ p \equiv a \mod p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span></span></span></span>。</p>
<h1 id="欧拉函数"><a class="header-anchor" href="#欧拉函数"># </a>欧拉函数</h1>
<p>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 是正整数，小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 且与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 互质的正整数的个数称为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的欧拉函数，记为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varphi(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<ul>
<li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 是素数，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\varphi(n) = n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</li>
<li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mi>p</mi><mo>×</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">n = p \times q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 都是素数，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>φ</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>×</mo><mi>φ</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi>q</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varphi(n) = \varphi(p) \times \varphi(q) = (p - 1) \times (q - 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li>
</ul>
<h1 id="欧拉定理"><a class="header-anchor" href="#欧拉定理"># </a>欧拉定理</h1>
<p>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 互素，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></msup><mo>≡</mo><mn>1</mn><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">a ^ {\varphi(n)} \equiv 1 \mod n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">φ</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span>。</p>
<blockquote>
<p>费马小定理是欧拉定理的特殊情况：当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">n = p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>p</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\varphi(n) = p - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
</blockquote>
<h1 id="Miller-Rabin-概率检测素数算法"><a class="header-anchor" href="#Miller-Rabin-概率检测素数算法"># </a>Miller-Rabin 概率检测素数算法</h1>
<p>原理：</p>
<ol>
<li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 为大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的素数，则方程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>≡</mo><mn>1</mn><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">x ^ 2 \equiv 1 \mod p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span></span></span></span> 的解只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x = -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</li>
<li><a href="#%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86">费马小定理</a>。</li>
</ol>
<pre><code class="language-cpp">/*
 * 用法：取不同的 2 &lt;= a &lt; n，检测 n 是否是素数
 * 输入：a, n
 * 输出：若返回 false，则 n 一定不是素数，否则 n 有概率是素数
 */
bool witness(const int &amp; a, const int &amp;n)  {
    b = n - 1, k = -1;
    while (b) b &gt;&gt;= 1, k++;  // bk...b0
    b = n - 1;  // 用于算 a ^ (n - 1) % n
    d = 1;  // 两个用途：d = x ^ 2 % n, d = a ^ (n - 1) % n
    for (int i = k; i &gt;= 0; i--) {
        x = d;
        d = d * d % n;  // d = x ^ 2 % n
        if (d == 1 &amp;&amp; x != 1 &amp;&amp; x != n - 1) return false;  // 违反了解只有 1 和 -1
        if (b &gt;&gt; i &amp; 1 == 1) d = d * a % n;  // bi = 1
    }
    if (d != 1) return false;  // 违反了费马小定理
    return true;
}
</code></pre>
<h1 id="欧几里得算法-辗转相除法"><a class="header-anchor" href="#欧几里得算法-辗转相除法"># </a>欧几里得算法 / 辗转相除法</h1>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a, b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span></span></span></span> 是任意两个正整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>&gt;</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a &gt; b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>，它们的最大公因子 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(a, b) = gcd(b, a \mod b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>。<br>
停止条件：</p>
<ul>
<li>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a \mod b = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">gcd(a, b) = b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>。</li>
<li>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>b</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a \mod b = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>b</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(a, b) = a \mod b = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</li>
</ul>
<h1 id="扩展欧几里得算法"><a class="header-anchor" href="#扩展欧几里得算法"># </a>扩展欧几里得算法</h1>
<p>通过辗转相除法可推出：存在整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo separator="true">,</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">s, t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span></span></span></span>，使得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>a</mi><mo>+</mo><mi>t</mi><mi>b</mi><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">sa + tb = gcd(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>，即两个数的最大公因数可以由这两个数线性表示。<br>
扩展欧几里得算法先通过<a href="#%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95-%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95">欧几里得算法</a>求出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>，若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(a, b) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，则有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>a</mi><mo>+</mo><mi>t</mi><mi>b</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">sa + tb = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>b</mi><mo>≡</mo><mn>1</mn><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>a</mi></mrow><annotation encoding="application/x-tex">tb \equiv 1 \mod a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>a</mi></mrow><annotation encoding="application/x-tex">\mod a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span></span></span></span> 下有乘法逆元 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>。</p>
<pre><code class="language-cpp">/*
 * 用法：求解 ax + by = gcd(a, b) 中的 x 和 y
 * 输入：a, b (a &gt; b)
 * 输出：返回是否有乘法逆元。若 y3 = 1，则有 gcd(a, b) = 1，即 b 在 mod a 下有乘法逆元 y；否则 gcd(a, b) = x3，无乘法逆元
 */
bool extendedEuclid(const int &amp;a, const int &amp;b, int &amp;x, int &amp;y) {
    int x3 = a, y3 = b;  // 用于辗转相除求 gcd(a, b)
    int x1 = 1, y1 = 0;  // 满足 ax1 + bx = x3 = a, ay1 + by = y3 = b
    x = 0, y = 1;
    int t1, t2, t3, q;
    while (y3 != 0 &amp;&amp; y3 != 1) {  // 辗转相除还未到停止条件
        q = x3 / y3;
        t1 = x1 - q * y1, t2 = x - q * y, t3 = x3 - q * y3;
        x1 = y1, x = y, x3 = y3;
        y1 = t1, y = t2, y3 = t3;  // 通过数学归纳法可得到 ay1 + by = y3，当 y3 = 1 时，gcd(a, b) = 1，即 ay1 + by = 1，b 在 mod a 下有乘法逆元 y
    }
    while (y &lt; 0) y += a;  // 求解出来的 y 可能是负数
    return y3 == 1 || x == 1;
}
</code></pre>
<h1 id="求乘法逆元"><a class="header-anchor" href="#求乘法逆元"># </a>求乘法逆元</h1>
<ul>
<li><a href="#%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86">费马小定理</a>：若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 是素数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 是正整数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(a, p)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">\mod p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span></span></span></span> 下的乘法逆元为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>p</mi><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">a ^ {p - 2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>。</li>
<li><a href="#%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">扩展欧几里得</a>：若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mtext>  </mtext><mo stretchy="false">(</mo><mi>a</mi><mo>&gt;</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a, b \; (a &gt; b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> 是正整数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(a, b)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>a</mi></mrow><annotation encoding="application/x-tex">\mod a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span></span></span></span> 下的乘法逆元为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mtext>  </mtext><mo stretchy="false">(</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y \; (ax + by = 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li>
</ul>
<blockquote>
<p>在 RSA 中，已知公钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span> 和欧拉函数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varphi(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，需要求满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>⋅</mo><mi>e</mi><mo>≡</mo><mn>1</mn><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d \cdot e \equiv 1 \mod \varphi(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的私钥 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>。因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>q</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\varphi(n) = (p - 1)(q - 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 必为合数，所以不可用费马小定理求解。因为选取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span> 时满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>e</mi><mo separator="true">,</mo><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(e, \varphi(n)) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，所以可用扩展欧几里得求解，且必存在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>。</p>
</blockquote>
]]></content>
      <categories>
        <category>一起学习吧</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>信息安全</tag>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Visual Studio 帮助学习《计算机组成原理》</title>
    <url>/2020/09/VSCO/</url>
    <content><![CDATA[<p>x86采用小端方式存储数据，数据按边界对齐存储</p>
<h1 id="C"><a class="header-anchor" href="#C"># </a>C++</h1>
<h2 id="设置C-断点"><a class="header-anchor" href="#设置C-断点"># </a>设置C++断点</h2>
<p><img src="/2020/09/VSCO/1.jpg" alt="1"></p>
<h2 id="查看C-变量地址"><a class="header-anchor" href="#查看C-变量地址"># </a>查看C++变量地址</h2>
<p>点击【开始调试】后<br>
打开【调试】【快速监视】输入<code>&amp;变量</code>（即：取地址），点【重新计算】，即可得到变量的地址<br>
<img src="/2020/09/VSCO/2.jpg" alt="2"></p>
<h2 id="查看内存"><a class="header-anchor" href="#查看内存"># </a>查看内存</h2>
<p>点击【开始调试】后<br>
打开【调试】【窗口】【内存】，即可调出内存窗口<br>
输入变量地址即可查看内存中该变量的存储情况<br>
<img src="/2020/09/VSCO/3.jpg" alt="3"></p>
<h2 id="查看C-生成的汇编语言"><a class="header-anchor" href="#查看C-生成的汇编语言"># </a>查看C++生成的汇编语言</h2>
<p>点击【开始调试】后<br>
打开【调试】【窗口】【反汇编】，即可看到C++生成的汇编语言<br>
<img src="/2020/09/VSCO/4.jpg" alt="4"></p>
<h2 id="查看寄存器"><a class="header-anchor" href="#查看寄存器"># </a>查看寄存器</h2>
<p>点击【开始调试】后<br>
打开【调试】【窗口】【寄存器】，即可看到各寄存器中的数据<br>
<img src="/2020/09/VSCO/5.jpg" alt="5"></p>
<hr>
<h1 id="ASM"><a class="header-anchor" href="#ASM"># </a>ASM</h1>
<h2 id="ASM配置"><a class="header-anchor" href="#ASM配置"># </a>ASM配置</h2>
<ol>
<li>
<p>创建一个 Visual C++ 空工程，此时先不要添加汇编源文件</p>
</li>
<li>
<p>在【解决方案浏览器】视图中，在【项目名称】上右击选择【生成依赖项】【生成自定义】，勾选【masm(.targets, .props)】项<br>
<img src="/2020/09/VSCO/6.jpg" alt="6"></p>
</li>
<li>
<p>在【解决方案浏览器】视图中，在【项目名称】上右击选择【属性】，在左侧【配置属性】导航中，选择【链接器】【系统】， 在【子系统】右侧下拉菜单中选择【控制台(/SUBSYSTEM:CONSOLE)】<br>
<img src="/2020/09/VSCO/7.jpg" alt="7"></p>
</li>
<li>
<p>添加汇编源代码<code>filename.asm</code>（添加C++文件，然后修改为<code>.asm</code>后缀），（这一步要放在最后，否则可能会报错）</p>
</li>
</ol>
<h2 id="引入依赖库Irvine"><a class="header-anchor" href="#引入依赖库Irvine"># </a>引入依赖库Irvine</h2>
<ol>
<li>
<p>链接器中添加包含路径：在【解决方案资源管理器】中, 项目名称上右击选择【属性】【链接器】【常规】【附加库目录】，<code>C:\Irvine</code><br>
<img src="/2020/09/VSCO/8.jpg" alt="8"></p>
</li>
<li>
<p>链接器中添加附加依赖项：在【解决方案资源管理器】中, 项目名称上右击选择【属性】【链接器】【输入】【附加依赖项】，主要包含库: <code>user32.lib</code>，<code>Irvine32.lib</code>，<code>kernel32.Lib</code><br>
<img src="/2020/09/VSCO/9.jpg" alt="9"></p>
</li>
</ol>
<h2 id="运行ASM"><a class="header-anchor" href="#运行ASM"># </a>运行ASM</h2>
<ol>
<li>
<p>设置断点<br>
<img src="/2020/09/VSCO/10.jpg" alt="10"></p>
</li>
<li>
<p>在运行时可能会出现【系统资源不足】无法运行的提示，只要将McAfee关掉即可</p>
</li>
</ol>
]]></content>
      <categories>
        <category>搞点什么东东吧</category>
      </categories>
      <tags>
        <tag>Visual Studio</tag>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
</search>
